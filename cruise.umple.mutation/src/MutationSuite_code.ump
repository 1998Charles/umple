

class MutationSuite {

depend java.util.*;
depend java.util.regex.*;
depend cruise.umple.parser.*;
depend cruise.umple.parser.analysis.RuleBasedParser;
depend java.io.*;
	
 public Boolean mutate(Mutant mu, String modelCode , String muType, String muOperator, String replacementType, String lang){
	   
	   
	   if (muType .equals( "random"))
	   {		   
		   if (muOperator .equals( "OneToMany"))
		   {
			   mutateAssociationOneToMany(mu, modelCode, replacementType,lang);
			   return true;
		   }
		   
		   if (muOperator .equals( "OneToOptionalOne"))
		   {
			   mutateAssociationOneToOptionalOne(mu, modelCode, replacementType,lang);
			   return true;
		   }
		   
		   if (muOperator .equals( "OptionalOneToMany"))
		   {
			   mutateAssociationOptionalOneToMany(mu, modelCode,replacementType, lang);
			   return true;
		   }
		   
		   if (muOperator .equals( "OneToNN"))
		   {
			   mutateAssociationOneToNN(mu, modelCode,replacementType, lang);
			   return true;
		   }
		   
		   if (muOperator .equals( "direction"))
		   {
			   mutateAssociationDirectionality(mu, modelCode,replacementType, lang);
			   return true;
		   }
		   
		   if (muOperator .equals( "ConstraintBiggerEq"))
		   {
			   mutateConstraintsBiggerEq(mu, modelCode,replacementType, lang);
			   return true;
		   }
		   
		   if (muOperator .equals( "ConstraintBigger"))
		   {
			   mutateConstraintsBigger(mu, modelCode,replacementType, lang);
			   return true;
		   }
	   }
	   
	   if (muOperator.equals( "full"))
	   {
		   mutateAssociationOneToMany(mu, modelCode,replacementType,lang);
		   mutateAssociationOptionalOneToMany(mu, modelCode,replacementType, lang);
		   mutateAssociationOneToNN(mu, modelCode,replacementType, lang);
		   mutateAssociationDirectionality(mu, modelCode,replacementType, lang);
		   mutateAttributeTypedString(mu, modelCode,replacementType, lang);
		   mutateAttributeTypedInteger(mu, modelCode,replacementType, lang);
		   mutateAttributeTypedFloat(mu, modelCode,replacementType, lang);
		   mutateAttributeTypedDouble(mu, modelCode,replacementType, lang);
		   mutateAssociationOneToOptionalOne(mu, modelCode, replacementType,lang);
		   mutateConstraintsBiggerEq(mu, modelCode,replacementType, lang);
		   mutateConstraintsBigger(mu, modelCode,replacementType, lang);
		   return true;
	   }
	   
	   if (muOperator .equals( "direction"))
	   {
		   mutateAssociationDirectionality(mu, modelCode,replacementType, lang);
		   return true;
	   }
	   
	   if (muOperator .equals( "Association"))
	   {
		   mutateAssociationOneToMany(mu, modelCode,replacementType,lang);
		   mutateAssociationOptionalOneToMany(mu, modelCode,replacementType, lang);
		   mutateAssociationOneToNN(mu, modelCode,replacementType, lang);
		   mutateAssociationDirectionality(mu, modelCode,replacementType, lang);
		   return true;
		   
	   }
	   
	   if (muOperator .equals( "Attribute"))
	   {
		   mutateAttributeTypedString(mu, modelCode,replacementType, lang);
		   mutateAttributeTypedInteger(mu, modelCode,replacementType, lang);
		   mutateAttributeTypedFloat(mu, modelCode,replacementType, lang);
		   mutateAttributeTypedDouble(mu, modelCode,replacementType, lang);
		   return true;
	   }
	   
	   if (muOperator .equals( "AttributeInt"))
	   {
		   
		   mutateAttributeTypedInteger(mu, modelCode,replacementType, lang);
		   
		   return true;
	   }
	   
	   if (muOperator .equals( "AttributeString"))
	   {
		   
		   mutateAttributeTypedString(mu, modelCode,replacementType, lang);
		   
		   return true;
	   }
	   
	   if (muOperator .equals( "AttributeFloat"))
	   {
		   
		   mutateAttributeTypedFloat(mu, modelCode,replacementType, lang);
		   
		   return true;
	   }
	   
	   if (muOperator .equals( "AttributeDouble"))
	   {
		   
		   mutateAttributeTypedDouble(mu, modelCode,replacementType, lang);
		   
		   return true;
	   }
	   
	   
	   if (muOperator .equals( "OneToMany"))
	   {
		   mutateAssociationOneToMany(mu, modelCode,replacementType,lang);
		   return true;
	   }
	   if (muOperator .equals( "OptionalOneToMany"))
	   {
		   mutateAssociationOptionalOneToMany(mu, modelCode,replacementType, lang);
		   return true;
	   }
	   
	   if (muOperator .equals( "OneToNN"))
	   {
		   mutateAssociationOneToNN(mu, modelCode,replacementType,lang);
		   return true;
	   }
	   
	   
	   if (muOperator .equals( "ConstraintBiggerEq"))
	   {
		   mutateConstraintsBiggerEq(mu, modelCode,replacementType,lang);
		   return true;
	   }
	   
	   if (muOperator .equals( "ConstraintBigger"))
	   {
		   mutateConstraintsBiggerEq(mu, modelCode,replacementType,lang);
		   return true;
	   }
	   
	   
	   
	   
    return false;
  }

   public Boolean generateMuCode(Mutant mu){
    return null;
  }


   public Boolean mutateAssociationOneToMany(Mutant mu, String modelCode,String replacementType,String lang){
	   String muModelCode = "";
	   String modelFileName="";
	   File modelFile;
	   UmpleModel mutatedModel = new UmpleModel(null); 
	   
		  //String regex = "[^0..]1\\s*\\w*\\s*--\\s*\\*\\s+\\w(\\s+\\w*)?";
	   String regex = "[^0..]1\\s*\\w*\\s*--\\s*\\*\\s+\\w(\\s+\\w*)?";
		  String replacement = " 0..1 ";
		  
		  if (replacementType .equals( "random"))
		  {
			  Collections.shuffle(randomReplacements_association);
			  replacementType = randomReplacements_association.get(0);
		  }
		  
		  if (replacementType .equals( "OptionalOneToMany"))
		  {
			  replacement = " 0..1 ";
		  }
		  
		  if (replacementType .equals( "ManyToMany"))
		  {
			  replacement = " * ";
		  }
		  
		  if (replacementType .equals( "OneToOne"))
		  {
			  replacement = " 1 ";
		  }
		  		  		  		  		  
		  muModelCode = modifyModelCode(modelCode, regex, replacement, "OneToMany");
		  //System.out.println(matcher.group());
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  //muModelCode= "namespace OptionalOneToMany;\n"+muModelCode;
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  
		  modelFileName =this.writeMutatedFile(path, uFileName, "OneToMany", muModelCode);
		  modelFile = new File (modelFileName);
		  UmpleFile umpleFile = new UmpleFile (modelFile);
		  //System.out.println("ModelFILENAME  ");
		  //System.out.println(modelFileName);
		  this.addMutant(new Mutant(new UmpleModel(umpleFile),"OneToMany", this));
		  try {
			
			 this.createUmpleMutationSystem(path, "OneToManyMutation_"+ uFileName, lang,"OneToMany");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		  
		  
		  
	  //mutatedModel.setCode(muModelCode);  
	  //Mutant aMutant = new Mutant(mutatedModel, "OptionalOneToMany", this);
	  //this.addMutant(aMutant);
	   
	   return null;
  }
   
   
   public Boolean mutateAssociationOneToOptionalOne(Mutant mu, String modelCode,String replacementType,String lang){
	   String muModelCode = "";
	   String modelFileName="";
	   File modelFile;
	   UmpleModel mutatedModel = new UmpleModel(null); 
	   
		  //String regex = "[^0..]1\\s*\\w*\\s*--\\s*\\*\\s+\\w(\\s+\\w*)?";
	   String regex = "[^0..]1\\s*\\w*\\s*--\\s*0..1\\s+\\w(\\s+\\w*)?";
		  String replacement = " 1 -- 0..1 ";
		  
		  if (replacementType .equals( "random"))
		  {
			  Collections.shuffle(randomReplacements_association);
			  replacementType = randomReplacements_association.get(0);
		  }
		  
		  if (replacementType .equals( "OptionalOneToMany"))
		  {
			  replacement = " 0..1 -- * ";
		  }
		  
		  if (replacementType .equals( "ManyToMany"))
		  {
			  replacement = " * -- * ";
		  }
		  
		  if (replacementType .equals( "OneToOne"))
		  {
			  replacement = " 1 -- 1 ";
		  }
		  if (replacementType .equals( "OneToMany"))
		  {
			  replacement = " 1 -- * ";
		  }
		  
		  
		  		  		  		  		  
		  muModelCode = modifyModelCode(modelCode, regex, replacement, "OneToOptionalOne");
		  //System.out.println(matcher.group());
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  //muModelCode= "namespace OptionalOneToMany;\n"+muModelCode;
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  
		  modelFileName =this.writeMutatedFile(path, uFileName, "OneToOptionalOne", muModelCode);
		  modelFile = new File (modelFileName);
		  UmpleFile umpleFile = new UmpleFile (modelFile);
		  //System.out.println("ModelFILENAME  ");
		  //System.out.println(modelFileName);
		  this.addMutant(new Mutant(new UmpleModel(umpleFile),"OneToOptionalOne", this));
		  try {
			
			 this.createUmpleMutationSystem(path, "OneToOptionalOneMutation_"+ uFileName, lang,"OneToOptionalOne");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		  
		  
		  
	  //mutatedModel.setCode(muModelCode);  
	  //Mutant aMutant = new Mutant(mutatedModel, "OptionalOneToMany", this);
	  //this.addMutant(aMutant);
	   
	   return null;
  }

  
   public Boolean mutateAssociationOptionalOneToMany(Mutant mu, String modelCode,String replacementType, String lang){
	      
	   String muModelCode = "";
	   String modelFileName="";
	   File modelFile;
	   UmpleModel mutatedModel = new UmpleModel(null); 
 
	   String regex = "\\s0..1\\s*\\w*\\s*--\\s*\\*\\s+\\w(\\s+\\w*)?";
	   String replacement = " 0..1 -- * ";
		  
		  if (replacementType .equals( "random"))
		  {
			  Collections.shuffle(randomReplacements_association);
			  replacementType = randomReplacements_association.get(0);
		  }
		  
		  if (replacementType .equals( "OneToMany"))
		  {
			  replacement = " 1 -- * ";
		  }
		  
		  if (replacementType .equals( "ManyToMany"))
		  {
			  replacement = " * -- * ";
		  }
		  
		  if (replacementType .equals( "OneToOne"))
		  {
			  replacement = " 1 -- 1 ";
		  }
		  
		  if (replacementType .equals( "ManyToMany"))
		  {
			  replacement = " * -- * ";
		  }
		  
		  if (replacementType .equals( "OneToOne"))
		  {
			  replacement = " 1 -- 1 ";
		  }
		  
		  
		  muModelCode = modifyModelCode(modelCode, regex, replacement,"OptionalOneToMany");
		  //System.out.println(matcher.group());
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  //muModelCode= "namespace OptionalOneToMany;\n"+muModelCode;
		  
		  modelFileName =this.writeMutatedFile(path, uFileName, "OptionalOneToMany", muModelCode);
		  modelFile = new File (modelFileName);
		  //UmpleFile umpleFile = new UmpleFile (modelFile);
		  UmpleModel muModel = new UmpleModel(null);
		  //System.out.println("ModelFILENAME  ");
		  //System.out.println(modelFileName);
		  
		  try {
			
			 muModel = this.createUmpleMutationSystem(path, "OptionalOneToManyMutation_"+ uFileName, lang,"OptionalOneToMany");
			 this.addMutant(new Mutant(muModel,"OptionalOneToMany", this));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		  
		  
		  
	  //mutatedModel.setCode(muModelCode);  
	  //Mutant aMutant = new Mutant(mutatedModel, "OptionalOneToMany", this);
	  //this.addMutant(aMutant);
	   
	   return null;
  
  }

   public Boolean mutateAssociationDirectionality(Mutant mu, String modelCode,String replacementType, String lang){
 	  
	   String muModelCode = "";
	   StringBuffer muCode = new StringBuffer(modelCode);
	   String modelFileName="";
	   File modelFile;
	   UmpleModel mutatedModel = new UmpleModel(null); 
	   Random ran = new Random();
	   
	   
			
	   	  
	   
	   String regex = "\\s?--\\s?";
	   String replacement = " -> ";
		  
		  
		  //muModelCode = modelCode.replaceAll(regex, replacement);
		  /*
		  Pattern pattern = Pattern.compile(regex);
		  Matcher matcher = pattern.matcher(modelCode);
		  
		  //matcher.find();
		  //muModelCode= modelCode.replace(matcher.group(), matcher.group().replace("0..1",replacement));
		   
		  muModelCode = modelCode;
		  int numberOfOccurences = 0;
		  while(matcher.find()) {
			  numberOfOccurences++;
		  }		
		  
		  matcher.reset();	
		  
		  	   
		  int random = ran.nextInt(numberOfOccurences);
		   
		  System.out.println("Number of Occurences: "+numberOfOccurences);
		  System.out.println("random: "+ (random+1));
		  
		  matcher.reset();		  
		  //matcher
		  int x=0;
		  
		  
		  //System.out.println(matcher.groupCount());
		  while(matcher.find())		  
		  //for ( x = 0;x>numberOfOccurences;x++)
		  {
			  			  
		      if(x == random){
			  System.out.println(matcher.group().toString());			  
			  muCode = muCode.replace(matcher.start(), matcher.end(), replacement);
			  System.out.println(muModelCode.indexOf(matcher.group()))	;
			  
			  System.out.println("indexes: ");
		      System.out.println(matcher.start());
		      System.out.println(matcher.end());
		      
		      }		      
		      x++;		                  
		  }
		  */
	   
	      
		  //System.out.println(muCode.toString());
		  //muModelCode = muCode.toString();
		  muModelCode = modifyModelCode(modelCode, regex, replacement,"AssociationDirectionality");
		  
		  //System.out.println(matcher.group());
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  //muModelCode= "namespace OptionalOneToMany;\n"+muModelCode;
		  modelFileName =this.writeMutatedFile(path, uFileName,  "AssociationDirectionality", muModelCode);
		  modelFile = new File (modelFileName);
		  UmpleFile umpleFile = new UmpleFile (modelFile);
		  //System.out.println("ModelFILENAME  ");
		  //System.out.println(modelFileName);
		  this.addMutant(new Mutant(new UmpleModel(umpleFile),"AssociationDirectionality", this));
		  try {
			
			 this.createUmpleMutationSystem(path, "AssociationDirectionalityMutation_"+uFileName, lang,"AssociationDirectionality");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		  
		  
	  //mutatedModel.setCode(muModelCode);  
	  //Mutant aMutant = new Mutant(mutatedModel, "OptionalOneToMany", this);
	  //this.addMutant(aMutant);
	   
	   return null;
  
  }
   public Boolean mutateAssociationOneToN(Mutant mu, String modelCode,String replacementType, String lang){
    String muModelCode="";
	  String regex = "1\\s*\\w*\\s*--\\s*\\d\\s+\\w\\s+\\w*";
	  String replacement = "";
	  UmpleModel mutatedModel = originalModel;
	  mutatedModel.getCode().replaceAll(regex, replacement);
	  //Mutant aMutant = new Mutant(mutatedModel, "OnetoN", this,"");
	  //this.addMutant(aMutant);
  return null;
  }
     
	  public Boolean mutateAssociationOneToNN(Mutant mu, String modelCode,String replacementType, String lang){
    
	   String regex = "[2-9]..[2-9]";
	   Pattern pattern = Pattern.compile(regex);
	   Matcher matcher = pattern.matcher(modelCode);
		  String muModelCode = "";
		  
		  String replacement = "REPCODE_OneToNN_1";
		  String replacement2 = "REPCODE_OneToNN_2";
		  String replacement3 = "REPCODE_OneToNN_3";
		  String replacement4 = "REPCODE_OneToNN_4";
		  
		  
		  muModelCode = modelCode.replaceAll(regex, replacement);
		  		 
		  matcher.find();
		  int upperBound = Integer.parseInt(matcher.group().substring(matcher.group().length()-1,matcher.group().length()));
		  int lowerBound = Integer.parseInt(matcher.group().substring(0,1));
		  String codeFragement = matcher.group().substring(1, matcher.group().length());
		//Mutation above Lower Bound
		  
		  //System.out.println(codeFragement);
		  //System.out.println(lowerBound);
		  String replacementFragmentCode = lowerBound+1 +codeFragement;
		  //System.out.println(replacementFragmentCode);
		  muModelCode = modelCode.replaceAll(regex, replacementFragmentCode);
		  this.writeMutatedFile(path, uFileName,  "OneToNN_aboveLowerBound", muModelCode);
		  
		//Mutation below Lower Bound
		  //matcher.find();
		  lowerBound = Integer.parseInt(matcher.group().substring(0,1));
		  //System.out.println(codeFragement);
		  //System.out.println(lowerBound);
		  replacementFragmentCode = lowerBound-1 +codeFragement;
		  //System.out.println(replacementFragmentCode);
		  muModelCode = modelCode.replaceAll(regex, replacementFragmentCode);
		  this.writeMutatedFile(path, uFileName,  "OneToNN_belowLowerBound", muModelCode);
		  
		//Mutation below Lower Bound
		  //matcher.find();		  
		  codeFragement = matcher.group().substring(0, matcher.group().length()-1);;
		  //System.out.println(codeFragement);
		  //System.out.println(lowerBound);
		  replacementFragmentCode = codeFragement +( upperBound-1);
		  //System.out.println(replacementFragmentCode);
		  muModelCode = modelCode.replaceAll(regex, replacementFragmentCode);
		  this.writeMutatedFile(path, uFileName,  "OneToNN_belowUpperBound", muModelCode);
		  
		//Mutation above Lower Bound
		  //matcher.find();		  
		  codeFragement = matcher.group().substring(0, matcher.group().length()-1);;
		  //System.out.println(codeFragement);
		  //System.out.println(lowerBound);
		  replacementFragmentCode = codeFragement + (upperBound+1);
		  //System.out.println(replacementFragmentCode);
		  muModelCode = modelCode.replaceAll(regex, replacementFragmentCode);
		  this.writeMutatedFile(path, uFileName,  "OneToNN_aboveUpperBound", muModelCode);
		  
		  
		  
	  return null;
  }
   
   
   
   public Boolean mutateAttributeTypedString(Mutant mu, String modelCode,String replacementType, String lang){
	   String muModelCode = "";
	   String modelFileName="";
	   File modelFile;
	   UmpleModel mutatedModel = new UmpleModel(null); 

	   String regex = "String\\s*";
		  String replacement = "";
		  
		  if (replacementType == "random")
		  {
			  Collections.shuffle(randomReplacements_typedAttribute);
			  replacementType = randomReplacements_typedAttribute.get(0);
		  }
		  
		  if (replacementType == "Integer")
		  {
			  replacement = "Integer";
		  }
		  
		  if (replacementType == "Float")
		  {
			  replacement = "Float";
		  }
		  
		  if (replacementType == "Double")
		  {
			  replacement = "Double";
		  }
		  
		  if (replacementType == "String")
		  {
			  replacement = "String";
		  }
		  
		  
		  
		  
		  
		  //muModelCode = modelCode.replaceAll(regex, replacement);
		  
		  muModelCode = modifyModelCode(modelCode, regex, replacement, "TypedAttributeString");
		  //System.out.println(matcher.group());
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  //muModelCode= "namespace OptionalOneToMany;\n"+muModelCode;
		  modelFileName =this.writeMutatedFile(path, uFileName,  "TypedAttributeString", muModelCode);
		  modelFile = new File (modelFileName);
		  UmpleFile umpleFile = new UmpleFile (modelFile);
		  //System.out.println("ModelFILENAME  ");
		  //System.out.println(modelFileName);
		  this.addMutant(new Mutant(new UmpleModel(umpleFile),"TypedAttributeString", this));
		  try {
			 
			 this.createUmpleMutationSystem(path, "TypedAttributeStringMutation_"+ uFileName, lang,"TypedAttributeString");
			 
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		  return null;
	  }

   public Boolean mutateAttributeTypedInteger(Mutant mu, String modelCode,String replacementType, String lang){
	   String muModelCode = "";
	   String modelFileName="";
	   File modelFile;
	   UmpleModel mutatedModel = new UmpleModel(null); 
			
	   	  
	   
	   String regex = "Integer\\s";
		  String replacement = "Integer";
		  
		  if (replacementType == "random")
		  {
			  Collections.shuffle(randomReplacements_typedAttribute);
			  replacementType = randomReplacements_typedAttribute.get(0);
		  }
		  
		  if (replacementType == "Integer" || replacementType == "int")
		  {
			  replacement = "Integer";
		  }
		  
		  if (replacementType == "Float")
		  {
			  replacement = "Float";
		  }
		  
		  if (replacementType == "Double")
		  {
			  replacement = "Double";
		  }
		  
		  if (replacementType == "String")
		  {
			  replacement = "String";
		  }
		  
		  
		  
		  
		  
		  //muModelCode = modelCode.replaceAll(regex, replacement);
		  
		  muModelCode = modifyModelCode(modelCode, regex, replacement, "TypedAttributeInt");
		  //System.out.println(matcher.group());
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  //muModelCode= "namespace OptionalOneToMany;\n"+muModelCode;
		  modelFileName =this.writeMutatedFile(path, uFileName, "TypedAttributeInteger", muModelCode);
		  modelFile = new File (modelFileName);
		  UmpleFile umpleFile = new UmpleFile (modelFile);
		  //System.out.println("ModelFILENAME  ");
		  //System.out.println(modelFileName);
		  this.addMutant(new Mutant(new UmpleModel(umpleFile),"TypedAttributeInteger", this));
		  try {
			
			 this.createUmpleMutationSystem(path,"TypedAttributeIntegerMutation_"+ uFileName, lang,"TypedAttributeInteger");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		  return null;
	  }
   
   public Boolean mutateAttributeTypedFloat(Mutant mu, String modelCode,String replacementType, String lang){
	   String muModelCode = "";
	   String modelFileName="";
	   File modelFile;
	   UmpleModel mutatedModel = new UmpleModel(null); 
			
	   	  
	   
	    String regex = "Float\\s";
		  String replacement = "";
		  
		  if (replacementType == "random")
		  {
			  Collections.shuffle(randomReplacements_typedAttribute);
			  replacementType = randomReplacements_typedAttribute.get(0);
		  }
		  
		  if (replacementType == "Integer")
		  {
			  replacement = "Integer";
		  }
		  
		  if (replacementType == "Float")
		  {
			  replacement = "Float";
		  }
		  
		  if (replacementType == "Double")
		  {
			  replacement = "Double";
		  }
		  
		  if (replacementType == "String")
		  {
			  replacement = "String";
		  }
		  
		  
		  
		  
		  
		  //muModelCode = modelCode.replaceAll(regex, replacement);
		  
		  Pattern pattern = Pattern.compile(regex);
		  Matcher matcher = pattern.matcher(modelCode);
		  
		  
		  //matcher.find();
		  //muModelCode= modelCode.replace(matcher.group(), matcher.group().replace("0..1",replacement));
		   
		  muModelCode = modelCode;
		  while(matcher.find())		  		  		  
		  { 
			  //System.out.println(matcher.group().toString());			  
			  muModelCode= muModelCode.replace(matcher.group(), matcher.group().replace("Float",replacement));
		  
		  }
		  //System.out.println(matcher.group());
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  //muModelCode= "namespace OptionalOneToMany;\n"+muModelCode;
		  modelFileName =this.writeMutatedFile(path, uFileName,  "TypedAttributeFloat", muModelCode);
		  modelFile = new File (modelFileName);
		  UmpleFile umpleFile = new UmpleFile (modelFile);
		  //System.out.println("ModelFILENAME  ");
		  //System.out.println(modelFileName);
		  this.addMutant(new Mutant(new UmpleModel(umpleFile),"TypedAttributeFloat", this));
		  try {
			
			 this.createUmpleMutationSystem(path, "TypedAttributeFloatMutation_"+ uFileName, lang,"TypedAttributeFloat");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		  return null;
	  }
   
   public Boolean mutateAttributeTypedDouble(Mutant mu, String modelCode,String replacementType, String lang){
	   String muModelCode = "";
	   String modelFileName="";
	   File modelFile;
	   UmpleModel mutatedModel = new UmpleModel(null); 
			
	   	  
	   
	   String regex = "\\s*Double\\s*";
		  String replacement = "";
		  
		  if (replacementType == "random")
		  {
			  Collections.shuffle(randomReplacements_typedAttribute);
			  replacementType = randomReplacements_typedAttribute.get(0);
		  }
		  
		  if (replacementType == "Integer")
		  {
			  replacement = "Integer";
		  }
		  
		  if (replacementType == "Float")
		  {
			  replacement = "Float";
		  }
		  
		  if (replacementType == "Double")
		  {
			  replacement = "Double";
		  }
		  
		  if (replacementType == "String")
		  {
			  replacement = "String";
		  }
		  
		  
		  
		  
		  
		  //muModelCode = modelCode.replaceAll(regex, replacement);
		  
		  Pattern pattern = Pattern.compile(regex);
		  Matcher matcher = pattern.matcher(modelCode);
		  
		  
		  //matcher.find();
		  //muModelCode= modelCode.replace(matcher.group(), matcher.group().replace("0..1",replacement));
		   
		  muModelCode = modelCode;
		  while(matcher.find())		  		  		  
		  { 
			  //System.out.println(matcher.group().toString());			  
			  muModelCode= muModelCode.replace(matcher.group(), matcher.group().replace("Double",replacement));
		  
		  }
		  //System.out.println(matcher.group());
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  //muModelCode= "namespace OptionalOneToMany;\n"+muModelCode;
		  modelFileName =this.writeMutatedFile(path, uFileName,  "TypedAttributeDouble", muModelCode);
		  modelFile = new File (modelFileName);
		  UmpleFile umpleFile = new UmpleFile (modelFile);
		  //System.out.println("ModelFILENAME  ");
		  //System.out.println(modelFileName);
		  this.addMutant(new Mutant(new UmpleModel(umpleFile),"TypedAttributeDouble", this));
		  try {
			
			 this.createUmpleMutationSystem(path, "TypedAttributeDoubleMutation_"+ uFileName, lang,"TypedAttributeDouble");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		  return null;
	  }
   
   public Boolean mutateConstraintsBiggerEq(Mutant mu, String modelCode,String replacementType, String lang){
	   String muModelCode = "";
	   String modelFileName="";
	   File modelFile;
	   UmpleModel mutatedModel = new UmpleModel(null); 
			
	   	  
	   
	   String regex = "pre:\\s*\\w*\\s*>=";
		  String replacement = "";
		  
		  if (replacementType == "random")
		  {
			  Collections.shuffle(randomReplacements_typedAttribute);
			  replacementType = randomReplacements_typedAttribute.get(0);
		  }
		  
		  if (replacementType == "<")
		  {
			  replacement = "<";
		  }
		  
		  if (replacementType == "<=")
		  {
			  replacement = "<=";
		  }
		  
		  if (replacementType == ">")
		  {
			  replacement = ">";
		  }
		  
		  if (replacementType == "==")
		  {
			  replacement = "==";
		  }
		  
		  
		  
		  
		  
		  //muModelCode = modelCode.replaceAll(regex, replacement);
		  
		  Pattern pattern = Pattern.compile(regex);
		  Matcher matcher = pattern.matcher(modelCode);
		  
		  
		  //matcher.find();
		  //muModelCode= modelCode.replace(matcher.group(), matcher.group().replace("0..1",replacement));
		   
		  muModelCode = modelCode;
		  
		  
		  muModelCode = modifyModelCode(modelCode, regex, replacement, "ConstraintBiggerEq");
		  //System.out.println(matcher.group());
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  //muModelCode= "namespace OptionalOneToMany;\n"+muModelCode;
		  modelFileName =this.writeMutatedFile(path, uFileName,  "ConstraintsBiggerEq", muModelCode);
		  modelFile = new File (modelFileName);
		  UmpleFile umpleFile = new UmpleFile (modelFile);
		  //System.out.println("ModelFILENAME  ");
		  //System.out.println(modelFileName);
		  this.addMutant(new Mutant(new UmpleModel(umpleFile),"ConstraintsBiggerEq", this));
		  try {
			
			 this.createUmpleMutationSystem(path, "ConstraintsBiggerEqMutation_"+ uFileName, lang,"ConstraintsBiggerEq");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		  return null;
	  }
   
   public Boolean mutateConstraintsBigger(Mutant mu, String modelCode,String replacementType, String lang){
	   String muModelCode = "";
	   String modelFileName="";
	   File modelFile;
	   UmpleModel mutatedModel = new UmpleModel(null); 
			
	   	  
	   
	   String regex = "pre:\\s*\\w*\\s*>";
		  String replacement = "";
		  
		  if (replacementType == "random")
		  {
			  Collections.shuffle(randomReplacements_typedAttribute);
			  replacementType = randomReplacements_typedAttribute.get(0);
		  }
		  
		  if (replacementType == "<")
		  {
			  replacement = "<";
		  }
		  
		  if (replacementType == "<=")
		  {
			  replacement = "<=";
		  }
		  
		  if (replacementType == ">=")
		  {
			  replacement = ">=";
		  }
		  
		  if (replacementType == "==")
		  {
			  replacement = "==";
		  }
		  
		  
		  
		  
		  
		  //muModelCode = modelCode.replaceAll(regex, replacement);
		  
		  Pattern pattern = Pattern.compile(regex);
		  Matcher matcher = pattern.matcher(modelCode);
		  
		  
		  //matcher.find();
		  //muModelCode= modelCode.replace(matcher.group(), matcher.group().replace("0..1",replacement));
		   
		  muModelCode = modelCode;
		  
		  
		  muModelCode = modifyModelCode(modelCode, regex, replacement, "ConstraintBiggerEq");
		  //System.out.println(matcher.group());
		  //System.out.println("Mutated Code  ");
		  //System.out.println(muModelCode);
		  //muModelCode= "namespace OptionalOneToMany;\n"+muModelCode;
		  modelFileName =this.writeMutatedFile(path, uFileName,  "ConstraintsBiggerEq", muModelCode);
		  modelFile = new File (modelFileName);
		  UmpleFile umpleFile = new UmpleFile (modelFile);
		  //System.out.println("ModelFILENAME  ");
		  //System.out.println(modelFileName);
		  this.addMutant(new Mutant(new UmpleModel(umpleFile),"ConstraintsBiggerEq", this));
		  try {
			
			 this.createUmpleMutationSystem(path, "ConstraintsBiggerEqMutation_"+ uFileName, lang,"ConstraintsBiggerEq");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		  return null;
	  }
   
   public Boolean mutateAttributeLazy(Mutant mu, String modelCode,String replacementType, String lang){
	    String muModelCode = "";
			  String regex = "0..1\\s*\\w*\\s*--\\s*\\*\\s+\\w\\s+\\w*";
			  String replacement = "REPCODE_OptionalOneToMany";
			  
			  /*if (replacementType== "OneToMany" && replacementType!="OptionalOneToMany")
			  {
				  replacement = "1--*";
			  }*/
			  
			  muModelCode = modelCode.replaceAll(regex, replacement);
			  
			  //System.out.println("Mutated Code  ");
			  //System.out.println(muModelCode);
			  this.writeMutatedFile(path, uFileName,  "AttributeLazy", muModelCode);
		  //Mutant aMutant = new Mutant(mutatedModel, "OptionalOneToMany", this,"");
		  //this.addMutant(aMutant);
	  return null;
	  }
   
   public Boolean mutateAttributeImmutable(Mutant mu, String modelCode,String replacementType, String lang){
	    String muModelCode = "";
			  String regex = "0..1\\s*\\w*\\s*--\\s*\\*\\s+\\w\\s+\\w*";
			  String replacement = "REPCODE_OptionalOneToMany";
			  
			  /*if (replacementType== "OneToMany" && replacementType!="OptionalOneToMany")
			  {
				  replacement = "1--*";
			  }*/
			  
			  muModelCode = modelCode.replaceAll(regex, replacement);
			  
			  //System.out.println("Mutated Code  ");
			  //System.out.println(muModelCode);
			  this.writeMutatedFile(path, uFileName,  "AttributeImmutable", muModelCode);
		  //Mutant aMutant = new Mutant(mutatedModel, "OptionalOneToMany", this,"");
		  //this.addMutant(aMutant);
	  return null;
	  }
   
   
   public Boolean mutateExtraCodeOperatorBiggerThan(Mutant mu, String modelCode,String replacementType, String lang){
	    String muModelCode = "";
			  String regex = "0..1\\s*\\w*\\s*--\\s*\\*\\s+\\w\\s+\\w*";
			  String replacement = "REPCODE_OptionalOneToMany";
			  
			  /*if (replacementType== "OneToMany" && replacementType!="OptionalOneToMany")
			  {
				  replacement = "1--*";
			  }*/
			  
			  muModelCode = modelCode.replaceAll(regex, replacement);
			  
			  //System.out.println("Mutated Code  ");
			  //System.out.println(muModelCode);
			  this.writeMutatedFile(path, uFileName,  "AttributeImmutable", muModelCode);
		  //Mutant aMutant = new Mutant(mutatedModel, "OptionalOneToMany", this,"");
		  //this.addMutant(aMutant);
	  return null;
	  }
   
   public Boolean mutateExtraCodeOperatorSmallerThan(Mutant mu, String modelCode,String replacementType, String lang){
	    String muModelCode = "";
			  String regex = "0..1\\s*\\w*\\s*--\\s*\\*\\s+\\w\\s+\\w*";
			  String replacement = "REPCODE_OptionalOneToMany";
			  
			  /*if (replacementType== "OneToMany" && replacementType!="OptionalOneToMany")
			  {
				  replacement = "1--*";
			  }*/
			  
			  muModelCode = modelCode.replaceAll(regex, replacement);
			  
			  //System.out.println("Mutated Code  ");
			  //System.out.println(muModelCode);
			  this.writeMutatedFile(path, uFileName,  "AttributeImmutable", muModelCode);
		  //Mutant aMutant = new Mutant(mutatedModel, "OptionalOneToMany", this,"");
		  //this.addMutant(aMutant);
	  return null;
	  }
   
   public Boolean mutateExtraCodeOperatorEqual(Mutant mu, String modelCode,String replacementType, String lang){
	    String muModelCode = "";
			  String regex = "0..1\\s*\\w*\\s*--\\s*\\*\\s+\\w\\s+\\w*";
			  String replacement = "REPCODE_OptionalOneToMany";
			  
			  /*if (replacementType== "OneToMany" && replacementType!="OptionalOneToMany")
			  {
				  replacement = "1--*";
			  }*/
			  
			  muModelCode = modelCode.replaceAll(regex, replacement);
			  
			  //System.out.println("Mutated Code  ");
			  //System.out.println(muModelCode);
			  this.writeMutatedFile(path, uFileName,  "AttributeImmutable", muModelCode);
		  //Mutant aMutant = new Mutant(mutatedModel, "OptionalOneToMany", this,"");
		  //this.addMutant(aMutant);
	  return null;
	  }
	  
	  
public UmpleModel createUmpleMutationSystem(String pathToInput, String filename, String lang, String muType) throws IOException{
	   
	   //pathToInput= SampleFileWriter.rationalize("");
	   //filename = SampleFileWriter.rationalize(filename);
	   //System.out.println("filename::::");
	   //System.out.println(pathToInput+muType+"/"+filename);
	   BufferedReader br = new BufferedReader(new FileReader(pathToInput+muType+"/"+filename));
	   String modelCode = "";
	   String line = "";
	   File file = new File(pathToInput,muType+"/"+ filename);
	   String umpleParserName="UmpleInternalParser";
	   String language = lang;
	   RuleBasedParser rbp = new RuleBasedParser();	   
	   UmpleFile uFile = new UmpleFile (file);
	   
	   System.out.println(uFile.getPath());
	   UmpleModel model = new UmpleModel(uFile);
	   model.setShouldGenerate(true);
	   while ((line = br.readLine()) != null) {
		     //System.out.println(line);
		     modelCode += line+"\n";
		   }
	   //br.close();
	   //originalModel.setCode(modelCode);	   
	   model.setCode(modelCode);
	   
	   //model.addGenerate("");
	   
	   
	   UmpleParser uiParser = new UmpleInternalParser("cruise.umple.compiler",model,rbp);
	   //uiParser.analyze(true);
	   
	   ParseResult result = rbp.parse(file); 	   
	   model.extractAnalyzersFromParser(rbp);
	   model.setLastResult(result);
	   
	   //rbp.addGrammarFile("");
	   
//	   model.setUmpleFile(new UmpleFile(new File(pathToInput, filename)));
	   model.addGenerate(language);
	   ;
	   //model.setDefaultNamespace(pathToInput);
	   
	   //System.out.println("PATHTHTTHTHTH");
	   //System.out.println(model.getDefaultGeneratePath());
	   
	   result = uiParser.analyze(true);
	   
	   //System.out.println("PackaGE::::");
	   //model.setDefaultPackage(model.getDefaultNamespace());
	   //model.setDefaultNamespace(model.getDefaultPackage());
	   //model.getDefaultGenerate()
	   //System.out.println(model.getDefaultNamespace());
	   
	   //System.out.println(file.getAbsolutePath());
	   //System.out.println(file.getName());
	   //System.out.println(rbp.getRootToken());
	   
	   
	   
	   //System.out.println(result.getErrorMessages().toString());
	   System.out.println("Generting files for: "+ filename);
	   model.generate();
	   //System.out.println("GENCODEDEDEDE");
	   //System.out.println(model.getGeneratedCode());
	   
	   
	   
	    
	    /*model.setShouldGenerate(false);
	    //if( aTracer != null )
	    //	model.setTracer(new TracerDirective(aTracer));
	    
		   
	    
	    
	    
	    model = uiParser.getModel();*/
	    
	    //System.out.println(model.getUmpleFile());
	    
	    
	   // System.out.println(result.toString());
	    
	    //System.out.println(model.getAssociation(0).toString());
	    	    	    
	    
	    return model;
	   
	  }
   
   public String writeMutatedFile(String path, String modelName, String muType, String code){
    //File file= new File (path, filename);
	    
	   
	   //System.out.println("USEFILE WRITING");
	    code = modifyModelNameSpace(code, muType);
	    File file = new File(path+muType);
	    file.mkdirs();   
	    String filename = path +muType+ File.separator + muType + "Mutation_" + modelName ;
	    	    
	    
	    BufferedWriter bw = null;
		try {
			bw = new BufferedWriter(new FileWriter(filename));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}	   
		
		if(this.muFiles.size()>0)
		{
			code = modifyModelUseStatements(code, muType);
		}

	    try
	    {	
	      System.out.println("Wrtitng file: "+ filename);
	      bw.write(code);
	      bw.flush();	      
	    } catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	    finally
	    {
	      try {
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	    }
	    
	    //originalModel.getUmpleFile().addLinkedFiles("model2.ump");
	    
	    if(hasMultipleFiles)
	    {
	    	writeMutatedUseFiles(path, muType, code);
	    }
	    
	    
	    return filename;
	    
  }
   
   
   public String readUseFilesCode (String filename)   
   {
	   String code= "";
	   
	   BufferedReader br = null;
		try {
			br = new BufferedReader(new FileReader(path+uFileName));
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		   String line = null;
		   
		   try {
			while ((line = br.readLine()) != null) {
			     //System.out.println(line);
			     code += line+"\n";			     
			   }
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	   
	   
	   return code;
	   
   }
   
   public void writeMutatedUseFiles(String path, String muType, String code) {
	// TODO Auto-generated method stub
	   
	   for(String filename : muFiles)
	   {
		   //writeMutatedFile(path, filename, muType, code);
		   //System.out.println("muFileXXXXX:"+ filename);
		   
	   }
	
}

public boolean analyzeModelFiles (String path, String modelName, String modelCode)
   {
	   String regex = "use\\s\\w*.ump;";
	   modelCode = originalModel.getCode(); 
	   //String muModelCode = "";
	   StringBuffer muCode = new StringBuffer(modelCode);	   
	   Random ran = new Random();	   		  		  		  
	   Pattern pattern = Pattern.compile(regex);
	   Matcher matcher = pattern.matcher(modelCode);	   
	   //muModelCode = modelCode;
	   int numberOfOccurences = 0;
	   int random=0;
	   String filename="";
	   
	   while(matcher.find()) {
		   numberOfOccurences++;
		   filename = matcher.group().substring(4, matcher.group().length()-1);
		   
		   //System.out.println(filename);
		   this.muFiles.add(filename.toString());
		   
	   }	   
	   
	   //System.out.println("Code: "+modelCode);
	   System.out.println("Number of linked model files: "+numberOfOccurences);	   
	   matcher.reset();		  
	   
	   int x = 0;
	   //String filename = "";


	   //System.out.println(matcher.groupCount());	   
	   //System.out.println("muFles: "+x);
	   //System.out.println("MODEL FILENAME: "+filename);
	   
	   
	   
	 unprocessedFiles = muFiles.size();  
	   	   	   	   
	 if (numberOfOccurences>0)
	 {
		 return true;
	 }
		 
	   
	 else return false;
	   
   }
   
   
   public String modifyModelCode (String modelCode, String regex, String replacement, String muOperator)
   {
	   
	   String muModelCode = "";
	   StringBuffer muCode = new StringBuffer(modelCode);	   
	   Random ran = new Random();	   		  		  		  
	   Pattern pattern = Pattern.compile(regex);
	   Matcher matcher = pattern.matcher(modelCode);	   
	   muModelCode = modelCode;
	   int numberOfOccurences = 0;
	   int random=0;
	   
	   while(matcher.find()) {
		   numberOfOccurences++;
		   
	   }	   
	   
	   try {
		   random = ran.nextInt(numberOfOccurences);
	   }
	   catch (Exception e ){
		   System.out.println(e.getMessage());
	   }
	   System.out.println("Number of occurences: "+numberOfOccurences);
	   System.out.println("random element number: "+ (random+1));
	   matcher.reset();		  
	   int x = 0;


	   //System.out.println(matcher.groupCount());
	   while(matcher.find())		  
		   //for ( x = 0;x>numberOfOccurences;x++)
	   {

		   if(x == random){
			   
			   if(muOperator == "OneToMany")
			   {
				   muCode = muCode.replace(matcher.start(), matcher.start()+3, replacement);
			   }
			   
			   if(muOperator.equals("ConstraintBiggerEq"))
			   {
				   System.out.println(matcher.group().toString());
				   muCode = muCode.replace(matcher.end()-2, matcher.end(), replacement);
			   }
			   else {
				   //System.out.println(matcher.group());
				   muCode = muCode.replace(matcher.start(), matcher.end()-1, replacement);			   
			   }
		   }		      
		   x++;		                  
	   }

	   muModelCode = muCode.toString();
	   return  muModelCode;
	   
   }
   
   public String modifyModelNameSpace (String model, String muType)
   {
	   String regex = "namespace\\s\\w+[.\\w]*";
	   Pattern pattern = Pattern.compile(regex);
	   Matcher matcher = pattern.matcher(model);	   
	   try{
		   matcher.find();
		   model = model.replaceAll(regex, matcher.group()+"."+muType);
	   }
	   catch(Exception e)
	   {
		   
	   }
	   
	   
	   return model;
	   
   }
   
   public String modifyModelUseStatements (String model, String muType)
   {
	   String regex = "use";
	   Pattern pattern = Pattern.compile(regex);
	   Matcher matcher = pattern.matcher(model);	   
	   //matcher.find();	   
	   model = model.replaceAll("use ", "use "+muType+"Mutation"+"_");
	   
	   return model;
	   
   }
   
   public void prepare (String aPath, String aUFileName, String aLang, String replacementType, String muOperator)
   {
	   //MutationSuite muSuite = new MutationSuite(null, 0, null);
	   
	    path = aPath;	    
	    uFileName = aUFileName;
	    String randomElement = "";
	    
	   File aFile = new File(path+uFileName);
	   UmpleFile uFile = new UmpleFile(path+uFileName);
	   //UmpleModel umpleModel = new UmpleModel(uFile);
	   originalModel= new UmpleModel(uFile);
	   String lang = aLang;
	   String repType = replacementType;
	   String mutationOperator = muOperator;
	   //System.out.println("FRESHHSHSHS");
	   //System.out.println(umpleModel.);
	   String modelCode = "";	   
	   String muModelCode = "";	   	   
	   
	   BufferedReader br = null;
	try {
		br = new BufferedReader(new FileReader(path+uFileName));
	} catch (FileNotFoundException e) {
		// TODO Auto-generated catch block
		System.out.println("Unable to read model file !");
		e.printStackTrace();
	}
	   String line = null;
	   originalModel.setCode("");
	   try {
		while ((line = br.readLine()) != null) {
		     //System.out.println(line);
		     modelCode += line+"\n";
		     originalModel.setCode(originalModel.getCode()+line+"\n");
		   }
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	   
	  if(repType == "random")
	  {
	   //System.out.println("unshuffled collection of replacements:");
	   //System.out.println(randomReplacements_association);
	   //System.out.println("Shuffled collection:");
	   Collections.shuffle(randomReplacements_association);
	   //System.out.println(randomReplacements_association);
	   //System.out.println("Shuffle again collection:");
	   Collections.shuffle(randomReplacements_association);
	   //System.out.println(randomReplacements_association);
	   
	   //System.out.println("getting Random replacement:");
	   Collections.shuffle(randomReplacements_association);
	   //System.out.println(randomReplacements_association.get(0));	   	   	   	   
	   //System.out.println(aFile.getAbsolutePath());
	   //System.out.println(aFile.getPath());
	   //System.out.println(aFile.exists());
	   //System.out.println(modelCode);
	   	   
	   //System.out.println("Find a random Replacement and generate mutant: ");
	   randomElement = randomReplacements_association.get(0);
	   System.out.println("Randomly generated mutant with the following change: "+randomElement);
	  }
	   
	   // public Boolean mutate(Mutant mu, String modelCode , String muType, String muOperator, String replacementType, String lang){
	  analyzeModelFiles(aPath, aUFileName, muModelCode); 
	  
	  if (this.muFiles.size()>0)
	  {
		  
		  
		  for(String useModelFile : this.muFiles) {
			  uFileName = useModelFile;
			  String useFileCode = readUseFilesCode(uFileName);
			  System.out.println("Mutating linked file:  ");
			  System.out.println(useModelFile);
			  
			  //System.out.println(mutationOperator);
			  mutate(null, useFileCode, "random",mutationOperator,repType, lang);
			  //this.prepare(aPath, useModelFile, aLang, replacementType, muOperator);
		  }
		  /*int processedFiles = 0;
		  while(unprocessedFiles>0)
		  {
			  String useModelFile = muFiles.get(processedFiles);
			  //uFileName = muFiles;
			  String useFileCode = readUseFilesCode(uFileName);
			  System.out.println("Mutating linked file:  ");
			  System.out.println(useModelFile);
			  
			  //System.out.println(mutationOperator);
			  //mutate(null, useFileCode, "random",mutationOperator,repType, lang);
			  this.prepare(aPath, useModelFile, aLang, replacementType, muOperator);
			  unprocessedFiles--;
			  processedFiles++;
			  
		  }*/
		  
		  
	  }
	  
	  uFileName = aUFileName;	  
	  mutate(null, modelCode, "random",mutationOperator,repType, lang);
	   
	   
	   
   }

  // line 220 "../../../../src/MutationSuite_code.ump"
   /*public static void main(String [] args) throws IOException{
    Thread.currentThread().setUncaughtExceptionHandler(new UmpleExceptionHandler());
    Thread.setDefaultUncaughtExceptionHandler(new UmpleExceptionHandler());
    
    //prepare("src-gen-umple/cruise/umple/mutation/","model2.ump", "java","full","random");
       /*
       String path = "src-gen-umple/cruise/umple/mutation/";
        
	   File aFile = new File("src-gen-umple/cruise/umple/mutation/model2.ump");
	   UmpleFile uFile = new UmpleFile(aFile);
	   //UmpleModel umpleModel = new UmpleModel(uFile);
	   originalModel= new UmpleModel(uFile);
	   //System.out.println("FRESHHSHSHS");
	   //System.out.println(umpleModel.);
	   String modelCode = "";	   
	   String muModelCode = "";	   	   
	   
	   BufferedReader br = new BufferedReader(new FileReader("src-gen-umple/cruise/umple/mutation/model2.ump"));
	   String line = null;
	   originalModel.setCode("");
	   while ((line = br.readLine()) != null) {
	     //System.out.println(line);
	     modelCode += line+"\n";
	     originalModel.setCode(originalModel.getCode()+line+"\n");
	   }
	   	 
	   
	   //UmpleFile file = new UmpleFile ("src-gen-umple/cruise/umple/mutation/model.ump");
	   
	   
	   
	   //UmpleModel aOriginalModel = new UmpleModel (new  UmpleFile ("src-gen-umple/cruise/umple/mutation/model.ump"));
	   //aOriginalModel.setShouldGenerate(false);
	   
	   
	   //aOriginalModel.setUmpleFile(file);
	   MutationSuite muSuite = new MutationSuite(null, 0, null);
	   
	   System.out.println("unshuffled collection of replacements:");
	   System.out.println(muSuite.randomReplacements_association);
	   System.out.println("Shuffled collection:");
	   Collections.shuffle(muSuite.randomReplacements_association);
	   System.out.println(muSuite.randomReplacements_association);
	   System.out.println("Shuffle again collection:");
	   Collections.shuffle(muSuite.randomReplacements_association);
	   System.out.println(muSuite.randomReplacements_association);
	   
	   System.out.println("getting Random replacement:");
	   Collections.shuffle(muSuite.randomReplacements_association);
	   System.out.println(muSuite.randomReplacements_association.get(0));
	   
	   
	   
	   
	   //System.out.println(aFile.getAbsolutePath());
	   //System.out.println(aFile.getPath());
	   //System.out.println(aFile.exists());
	   //System.out.println(modelCode);
	   	   
	   System.out.println("Find a random Replacement and generate mutant: ");
	   String randomElement = muSuite.randomReplacements_association.get(0);
	   
	   muSuite.mutate(null, modelCode, randomElement,"full","random", "Java");
	   
	   System.out.println("Generated the following mutant: "+randomElement);
	   
	   
	   //muSuite.mutateAssociationOptionalOneToMany(null, modelCode);
	   //Mutant mutant = new Mutant(null,"OneToMany",muSuite,modelCode);
	   //System.out.println(muSuite.getMutants().toString());
	   
	   //muSuite.processReplacements();
	   //muSuite.mutateAssociationOptionalOneToMany(null, modelCode);
	   //muSuite.mutateAssociationOneToMany(null, modelCode);
	   //muSuite.mutateAssociationOneToNN(null, modelCode);
	   //muSuite.mutateRandom(null, modelCode);
	   //
	  //String muModelCodel="";
	  //String regex = "0..1 -- *";
	  //String replacement = "REPCODE";	  
	  //muModelCode = modelCode.replaceAll(regex, replacement);
	  
	  //System.out.println("Mutated Code  ");
	  //System.out.println(muModelCode);
	  //muSuite.writeMutatedFile("src-gen-umple/cruise/umple/mutation/", "model.ump", "OptionalOneToMany", muModelCode);
	  
	  
	  //UmpleModel muModel = muSuite.createUmpleMutationSystem("src-gen-umple/cruise/umple/mutation", "OptionalOneToManyMutation_model.ump", "Ruby");	  
	  //System.out.println(muSuite.getMutants().size());
	  
	  /*for ( int i = 0 ; i <= muSuite.muFiles.size(); i ++)		  
	  {
		  
		  muSuite.createUmpleMutationSystem("", muSuite.muFiles.get(i), "java");
	  }*/
	  
	  /*for (Mutant mu : muSuite.getMutants())
	  {
		  System.out.println("This is Umplefile from main list: ");
		  mu.getMuModel().getUmpleFile();
	  }
    
  }*/


}
