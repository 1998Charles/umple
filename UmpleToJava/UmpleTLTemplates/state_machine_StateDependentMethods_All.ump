class UmpleToJava {
    state_machine_StateDependentMethods_All <<!<</*state_machine_StateDependentMethods_All*/>><<#
    // Issue #1351
    if (!uClass.getStateDependentMethods().isEmpty()) {

      // Effectively a lambda function below, so that we can keep code related
      // to state-dependent method generation all in one space
      abstract class StateDependentTreeTraversal {
        public abstract void traverse(Method method);
      }
    
      StateDependentTreeTraversal t = new StateDependentTreeTraversal() {
    		
        // Prints the signature for the state-dependent method
        private void printBefore(Method method) {
          String methodModifier = method.getModifier().equals("") ? "public" : method.getModifier();
          String methodType = method.getType();
          String methodName = method.getName();
          StringBuilder parameters = new StringBuilder();
          String finalParams = "";
          if (method.hasMethodParameters())
          {
            for (MethodParameter aMethodParam : method.getMethodParameters()) 
            {
              String paramName = aMethodParam.getName();
              String paramType = aMethodParam.getType();
              String isList = aMethodParam.getIsList() ? " [] " : " ";
              String aSingleParameter = paramType + isList + paramName;
              parameters.append(aSingleParameter + ", ");
            }
        
            finalParams = parameters.toString().substring(0, parameters.toString().length()-2);
          }
      
          StringBuilder methodExceptionsBuilder = new StringBuilder();
          if(method.getExceptions()!=null&&method.numberOfExceptions()>0)
          {
            methodExceptionsBuilder.append(" throws ");
            String exceptioncomma = "";
            for(String methodException:method.getExceptions())
            {
              if(!"".equals(methodException))
              {
                methodExceptionsBuilder.append(exceptioncomma);
                methodExceptionsBuilder.append(methodException);
                exceptioncomma = ",";
              }
            }
          }

          String methodExceptions = methodExceptionsBuilder.toString();
          append(realSb, "\n  {0} {1} {2}({3}){4}", methodModifier, methodType, methodName, finalParams, methodExceptions);
        }
    
        // Prints the state-dependent method as defined within the UmpleClass
        public void traverse(Method method)
        {
          printBefore(method);
          Map<State, MethodBody> stateMap = uClass.getStateDependentMethodBodyMap().get(method);
          MethodBody defaultBody = stateMap.getOrDefault(null, null);
          for (StateMachine sm : uClass.getStateMachines())
          {
            StringBuilder smBuilder = new StringBuilder();
            append(smBuilder, "\n  {");
    	    boolean foundMethod = traverse(method, sm, null, defaultBody, stateMap, smBuilder, 1);
    	    append(smBuilder, "\n  }\n");
    	    if (foundMethod) realSb.append(smBuilder.toString());
          }
        }
    	
        // Returns true if methods were found. Do not use results of StringBuilder otherwise.
        private boolean traverse(Method method, StateMachine sm, State fromState, MethodBody defaultBody, Map<State, MethodBody> stateMap, StringBuilder builder, int depth) {
          boolean foundMethod = false;
      
          // Repeat spacing based on depth
          String spacing = new String(new char[depth]).replace("\0", "    ");
      
          // Non-trivial states should have a switch case:
          append(builder, "\n  {0}switch({1})", spacing, gen.translate("stateMachineOne", sm));
          append(builder, "\n  {0}{", spacing);
          
          // Loop over states and recurse
          for (State state : sm.getStates())
          {
            // Hierarchically set the default body based on state
            MethodBody childDefaultBody = stateMap.getOrDefault(state, defaultBody);

            boolean foundChildMethod = false;
            if (state.hasNestedStateMachines()) {
            	boolean shouldPrintCaseStatement = true;
            	for (StateMachine nestedSm : state.getNestedStateMachines())
                {
            	    StringBuilder childBuilder = new StringBuilder();
                  boolean result = traverse(method, nestedSm, state,
                		           childDefaultBody, stateMap, childBuilder,
                		           depth + 1);
                  
                  if (result)
                  {
                    foundChildMethod = true;
                	  if (shouldPrintCaseStatement)
                	  {
                		  append(builder, "\n  {0}  case {1}:", spacing, state.getName());
                	  }
                	  append(builder, childBuilder.toString());
                  }
                }
            }
            
            if (!foundChildMethod)
            {
            	// Handle leaf nodes
            	MethodBody body = stateMap.getOrDefault(state, null);
        	    if (body != null) {
        	    	append(builder, "\n  {0}  case {1}:", spacing, state.getName());
        	    	append(builder, "\n  {0}    {1}", spacing, body.getCodeblock().getCode());
        	    }
        	    foundMethod = foundMethod || body != null;
            }
            
          }
      
          // Output the default value and close brace
          String defaultValue = (defaultBody == null) ?
                                String.format("return %s;", gen.translate(method.getType()))
                                : defaultBody.getCodeblock().getCode();
          append(builder, "\n  {0}  default:", spacing);
          append(builder, "\n  {0}    {1}", spacing, defaultValue);
          
          // Close the switch statement
          append(builder, "\n  {0}}", spacing);
          
          return foundMethod;
        }
    };
  
    // Generate state-dependent methods
    for (Method method : uClass.getStateDependentMethods())
    {
      t.traverse(method);
    }
  }#>>!>>
}
