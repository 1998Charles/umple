/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

Parser for the grammar that can be used to define any grammar
UmpleParser.ump is the key example

*/
namespace cruise.umple.compiler;

class Couple
{
  open;
  close;
  0..1 -- 0..* Couple ignores;
}

/*
 * Represents the results of parsing, such as if it was successful, whether it had warnings, etc.
 */
class ParseResult
{
	// Specifies whether or not the parsing was successful.
	Boolean wasSuccess;
	
	// Specifies whether or not the parsing has warnings.
	Boolean hasWarnings = false;
	
	internal Boolean _acceptsErrors = true;
  
  	// Position is left for now, as not to break things
  	* -> 0..1 Position;
  	
  	// The error messages related to parsing.
  	* -> * ErrorMessage;

  	depend  cruise.umple.util.StringFormatter;
}

/*
 * Represents an error message, typically used with parsing.
 */
class ErrorMessage
{
	// Indicates the type of error.
  	* -> 1 ErrorType;
  	
	* -> 1 Position;
	
	String[] parameters;
		
	depend  cruise.umple.util.StringFormatter;
}

/*
 * Represents an error type, which contains an error code, the severity of the error, etc.
 */
class ErrorType
{
	// The error code.
	Integer errorCode;
	
	// The severity of the error.
	Integer severity;
	
	String errorFormat;
	String errorUrl;
	
	key {errorCode}
}

class ErrorTypeSingleton
{
	singleton;
	1 -> * ErrorType;
    
	depend cruise.umple.compiler.exceptions.UmpleCompilerException;
	depend cruise.umple.util.SampleFileWriter;
	depend java.io.*;
}

/*
 * Fundamental to all parsing, used in conjunction with rules and their definitions.  As parsing is taking place
 * these will indicate what is currently being looked for (such as a class definition or attribute) and helps to keep
 * track of the positions that the input parser parsed things at.
 */
class Token
{
	// The name of the token.
  	name;
  	
  	// The value of the token.
  	value;
  	0..1 parentToken -- * Token subTokens;
  	* -> 0..1 Position;
  
  	before getName { if (name == null) { return ""; } }
  	before getValue { if (value == null) { return ""; } }
  
  	before setPosition {String tFilename = position == null ? newPosition.getFilename() : position.getFilename();}
  	after setPosition {position.setFilename(tFilename);}
}

/*
 * Used to indicate the coordinates of a position when parsing.  This is done by keeping track of the
 * filename, the line number and the corresponding offset on that line number.
 */
class Position
{
	// The filename of the position.
  	String filename;
  	
  	// The line number of the position.
  	Integer lineNumber;
  	
  	// The character offset of the position.
  	Integer characterOffset;
  	
  	// The offset of the position.
  	Integer offset;

  	key { filename, lineNumber, characterOffset, offset }
}

/*
 * Represents a rule, which has a name and contains definitions that describe it.
 * 
 * Examples of this are a class definition.
 */
class Rule
{
	// The name of the rule.
  	name;
  	
  	Boolean shouldHide = false;
  	
  	// The definitions associated with the rule.
  	String[] definitions;
}

class RulePartValue
{
  String name = null;
  String value = null;
  * -> 0..1 Position;
}

class RulePart
{
  name;
  multiplicity;
  String[] nextIdentifiers;
  Integer maximumPartsFound = -1;
  type { Static, Variable, Rule }

  before addNextIdentifier { if (aNextIdentifier == null) { return false; } }
  before getMultiplicity { if (multiplicity == null) { return "1"; } }
}

class Parser
{
  depend java.io.*;
  depend cruise.umple.util.*;

  String filename = null;
  String name; // default 'program'
  String[] grammarRules;
  * -> * Rule;
  * -> * Couple;
  ParseResult parseResult = new ParseResult(true);
  internal Position _curParsePos = null;
  Token rootToken = reset();
}

class RuleInstance
{
  String[] stopAts;
  internal Integer updateIndex = -1;
  internal Integer rulePartsIndex = 0;
  * -> * RulePart;
  * -> 1 Parser;
}

use Parser_Code.ump;