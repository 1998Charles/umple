/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

This file generates .gv files for use by Graphviz, representing the feature diagram along in the Umple model. To generate for this format, use 
  generate GvFeatureDiagram;
in your umple file, or the command line option
  -g GvFeatureDiagram

*/

namespace cruise.umple.compiler;

class GvFeatureDiagramGenerator {
  depend cruise.umple.compiler.FeatureLink.FeatureConnectingOpType;
  UmpleModel model = null;
  // Template for what will appear at the start of each graph file
  graphStart(umpleVersion) <<!digraph FeatureModel{ 
  node [shape=rectangle]  
  edge [arrowhead=none] 
!>>

  emit graphStart()(graphStart(UmpleModel.VERSION_NUMBER));
  
  public void generateFeatureNodeShape(FeatureLink featureLink , StringBuilder code)
  {
    FeatureNode featureNode = ((FeatureNode) featureLink.getTargetFeature(0));
    FeatureNode sourceFeatureNode = featureLink.getSourceFeature();
    int indentLevel = 2;
    appendSpaces(code,indentLevel);
    if(featureNode.getIsLeaf())
    {

     if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Exclude))
      {
        code.append(""+sourceFeatureNode.getName()+sourceFeatureNode.getId()+" -> "+featureNode.getName()+" ");
        code.append("["+ "arrowhead=normal color=red constraint=false label=exclude " + "]");
        code.append(" ;"+"\n");
      }
      else if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Include))
      {
        code.append(""+sourceFeatureNode.getName()+sourceFeatureNode.getId()+" -> "+featureNode.getName()+" ");
        code.append("["+ "arrowhead=normal color=blue constraint=false label=include " + "]");
        code.append(" ;"+"\n");
      }
      else if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Optional))
      {
        code.append(""+sourceFeatureNode.getName()+sourceFeatureNode.getId()+" -> "+featureNode.getName()+" ");
        code.append("[arrowhead=odot]");
        code.append(" ;"+"\n");      
      }
      else if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Conjunctive))
      {
        code.append(""+sourceFeatureNode.getName()+sourceFeatureNode.getId()+" -> "+featureNode.getName()+" ");
        code.append("[arrowhead=dot]");
        code.append(" ;"+"\n");      
      }
      else if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Multiplicity))
      {
        MultiplicityFeatureConnectingOpType multiplicityFeatureLink = (MultiplicityFeatureConnectingOpType) featureLink;
        int upperBound = multiplicityFeatureLink.getMultiplicity().getUpperBound();
        int lowerBound = multiplicityFeatureLink.getMultiplicity().getLowerBound();
        String multip = "_"+lowerBound+"_"+upperBound;
        
        code.append(""+sourceFeatureNode.getName()+sourceFeatureNode.getId()+" -> "+multip + " ;"+"\n");
        
        List<FeatureNode> featureNodes = featureLink.getTargetFeature();
        indentLevel+=2;
        for(int i=0 ; i < featureNodes.size(); i++){
          FeatureLeaf fLeaf = ((FeatureLeaf)featureNodes.get(i));
          appendSpaces(code,indentLevel);
          code.append(multip +" -> "+ fLeaf.getName()+" ;"+"\n");
        }
      }
      else 
        code.append(""+sourceFeatureNode.getName()+sourceFeatureNode.getId()+" -> "+featureNode.getName()+" ;"+"\n");
    }
    else //if the node is not leaf node 
    {
      code.append(""+featureNode.getName()+featureNode.getId()+" "+getGvNodeShape(featureLink.getFeatureConnectingOpType())+" ;"+"\n");
      appendSpaces(code,indentLevel);
      code.append(""+sourceFeatureNode.getName()+sourceFeatureNode.getId()+" -> "+featureNode.getName()+featureNode.getId()+" ;"+"\n");
      List<FeatureLink> outgoingLinks = featureNode.getSourceFeatureLink();
      for(int i=0 ; i<outgoingLinks.size(); i++){
        generateFeatureNodeShape(outgoingLinks.get(i),code);
      }
    }
  }

  //This overrides the superclass's method.
  public void generate(){
    StringBuilder code = new StringBuilder();
    // Output basic gv file header
    if(getModel().getFeatureModel() == null)
    {
      code.append("/* Umple code does not have feature diagram. */");
      return;
    }
    _graphStart(0,code);
     // Iterate through each root feature. 
    for (FeatureNode featureNode : getModel().getFeatureModel().getRootFeatures())
    {
      List <FeatureLink> featureNodeOutLinks = featureNode.getSourceFeatureLink();
      for(FeatureLink flink : featureNodeOutLinks)
      {
        generateFeatureNodeShape(flink,code);
      }		    
    }

    terminateCode(code);
    // code.append(" \n } \n");
  }

  public static String getGvNodeShape(FeatureConnectingOpType featureConnectingOpType)
  { //audioXor [ label=\"\" shape=triangle fixedsize=true style=filled color=black width=.3 height=0.3 margin=0 ];
    switch(featureConnectingOpType)
    {
      case Conjunctive:
      return "";
      case Disjunctive:
      return "[label=\"\" shape=triangle fixedsize=true  color=black width=.3 height=0.3 margin=0 ] ";
      case XOR:
      return "[label=\"\" shape=triangle fixedsize=true style=filled color=black width=.3 height=0.3 margin=0 ]";
      default:
      return "";
    }
  }
  /*
   public boolean evaluateFeatureLink(FeatureLink featureLink)
  {
    FeatureNode featureNode = ((FeatureNode) featureLink.getTargetFeature(0));
    if(featureNode.getIsLeaf())
    {
      if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Include))
      {
        return isUsedFeatureLeaf((FeatureLeaf)featureNode);
      } 
      else if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Exclude))
      {
        return !isUsedFeatureLeaf((FeatureLeaf)featureNode); // return true when there is no use-statement, or no def for mixset 
      }
      else if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Optional))
      {
        return true;        // opt is allawys has a true value 
      }
      else if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Multiplicity))
      {
        MultiplicityFeatureConnectingOpType multiplicityFeatureLink = (MultiplicityFeatureConnectingOpType) featureLink;
        int upperBound = multiplicityFeatureLink.getMultiplicity().getUpperBound();
        int lowerBound = multiplicityFeatureLink.getMultiplicity().getLowerBound();
        List<FeatureNode> featureNodes = featureLink.getTargetFeature();
        int countOfUsedTarget = 0;
        for(int i=0 ; i < featureNodes.size(); i++){
          if(isUsedFeatureLeaf((FeatureLeaf)featureNodes.get(i)))
          countOfUsedTarget++;
        }
        return (countOfUsedTarget <= upperBound && countOfUsedTarget >= lowerBound) ? true: false;    
      }
      else 
      return isUsedFeatureLeaf((FeatureLeaf)featureNode);
    } // if not leaf node
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Conjunctive))
    { 
      if(!featureNode.getIsLeaf())
      {
        List<FeatureLink> outgoingLinks = featureNode.getSourceFeatureLink();
        boolean result = true;
        for(int i=0 ; i<outgoingLinks.size(); i++){
          result = result && evaluateFeatureLink(outgoingLinks.get(i));
        }
        return result;
      }
    }
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.Disjunctive))
    {   
      if(!featureNode.getIsLeaf())
      {
        boolean result = false;
        List<FeatureLink> outgoingLinks = featureNode.getSourceFeatureLink();
        for(int i=0 ; i<outgoingLinks.size(); i++){
          result = result || evaluateFeatureLink(outgoingLinks.get(i));
        }
        return result;
      }
    }
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureConnectingOpType.XOR))
    { 
      if(!featureNode.getIsLeaf())
          {
            List<FeatureLink> outgoingLinks = featureNode.getSourceFeatureLink();
            int countOfUsedTarget = 0;
            for(int i=0 ; i < outgoingLinks.size(); i++){
              if(evaluateFeatureLink(outgoingLinks.get(i)))  // bitwise xor (^) can not be used here because it does not mean always only one. Example: (true ^ true ^ true == true) 
              countOfUsedTarget++;
            }
            return (countOfUsedTarget == 1) ? true: false;
          }
    }
    //otherwise
    return false;
  }
*/
  protected void terminateCode(StringBuilder code){ 
    code.append("\n }\n");
    model.setCode(code.toString());
    writeModel();
  }

  protected String generatorType() { 
    return "GvFeatureDiagram";
  }
  // copied from "Generator_SuperGvGenerator.ump"
  private void appendSpaces(StringBuilder code, int numSpaces) 
  {
    for(int i=0; i<numSpaces; i++) 
    {
      code.append(" ");
    }
  }

  /**
   * Output the graphviz file to a file with the .gv suffix
   */
  // copied from "Generator_SuperGvGenerator.ump"
   protected void writeModel(){
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName()
          + generatorType() + ".gv";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating GraphViz feature model code." + e, e);
    }
  }

}
