/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

Graph Walking extensions

*/

namespace cruise.umple.compiler;

class Graph 
{
  public boolean hasNext () 
  {
    if (this.stack == null && this.queue == null) return false;
    if (this.isDepthFirst) return ! stack.isEmpty();
    return ! this.queue.isEmpty();
  }

  public boolean isDepthFirst()
  {
    return this.isDepthFirst;
  }

  // TODO this should be abstract but because of issue $$$ it makes child classes abstract.
  public Node nextNode(){return null;}
}

// TODO if both: change now
class StateMachineLevelGraph 
{

  public StateMachineLevelGraph(Node startNode, String smName, boolean isDepthFirst) 
  {
    this.startNode = startNode;
    this.startNode.visit();
    this.smName = smName;
    this.isDepthFirst = isDepthFirst;
    this.isNested = true;

    if(isDepthFirst) 
    {
      this.stack = new Stack<Node>();
      this.stack.push(this.startNode);
    }
    else
    {
      this.queue = new LinkedList<Node>();
      this.queue.addFirst(this.startNode);
    }
  }

  public StateMachineLevelGraph(Node startNode, boolean isDepthFirst)
  {
    this.startNode = startNode;
    this.startNode.visit();
    this.isDepthFirst = isDepthFirst;
    this.isNested = false;

    if(isDepthFirst)
    {
      this.stack = new Stack<Node>();
      this.stack.push(this.startNode);
    }
    else
    {
      this.queue = new LinkedList<Node>();
      this.queue.addFirst(this.startNode);
    }
  }

  /**
  * Visit and return the next state in the walk.
  */
  public Node nextNode() 
  {
    if (this.isDepthFirst) return walkDFS();
    return walkBFS();
  }


  private Node walkDFS () 
  { 
    if (stack == null || stack.isEmpty()) return null;
    State state = (State) stack.pop();
    
    for (Transition transition: state.getTransitions()) 
    {
      State nextState = (State) transition.getNextState();
      StateMachine sm = nextState.getStateMachine();

      if ((! nextState.getIsVisited()) && (!isNested || sm.getName().equals(this.smName)))
      {
        nextState.visit();
        stack.push(nextState) ;
      }
    }

    return state;
  }

  private Node walkBFS () 
  {
    if (queue == null || queue.isEmpty()) return null;
    State state = (State) queue.pollLast();
    state.visit();

    for (Transition transition: state.getTransitions()) 
    {
      State nextState = (State) transition.getNextState();
      StateMachine sm = nextState.getStateMachine();
      // TODO Confirm that the state stays in the same level
      //if (nextState.isInternal() && ! nextState.isVisited()) 
      if ((! nextState.getIsVisited()) && (!isNested || sm.getName().equals(this.smName)))
      {
        nextState.visit();
        queue.addFirst(nextState);
      }
    }

    return state;
  }
}


