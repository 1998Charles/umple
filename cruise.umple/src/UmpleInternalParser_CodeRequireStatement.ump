/*
Copyright: All contributers to the Umple Project.

This file is made available subject to the open source license found at:
http://umple.org/license

This file analyzses require statement tokens to populate Requiregraph for Umple model.

Please refer to UmpleInternalParser.ump for more details.
*/

class UmpleInternalParser
{
  depend cruise.umple.compiler.*;
  public void analyzeRequireStatement(Token t, int analysisStep)
  {
    if (analysisStep != 2)
    {
      shouldProcessAgain = shouldProcessAgain || (analysisStep == 1);
      return;
    }    
    if (t.is("requireStatement"))
    {
      FeatureModel featureModel = model.getFeatureModel();
      if(featureModel == null)
        featureModel = new FeatureModel("featureModel");
      featureModel.setUmpleModel(model);

      Mixset sourceMixset = getMixsetFromToken(t);
      FeatureLeaf sourceFeatureLeaf = new FeatureLeaf(featureModel);
      // require-statement comes from umple file or mixset ?
      if (sourceMixset == null) 
      sourceFeatureLeaf.setMixsetOrFileNode(new UmpleFile(t.getPosition().getFilename()));
      else 
      sourceFeatureLeaf.setMixsetOrFileNode(sourceMixset);
      
      boolean isSubFeature = t.getSubToken("subfeature") != null; 

       //tokens needed for parsing require-statement
      List<String> acceptedTokensList = Arrays.asList("requireTerminal","and","not","xor","or","opt");
      ArrayList<Token> requireTokenList = getRequireStatementTokensAsList(t, acceptedTokensList);      
      Token firstTokenOfRequireTokenList;

      if(requireTokenList.size() == 0 ) // require [ ]
      return;

      if (requireTokenList.size() >= 1)  // has the form of : require [A and B or C .... ]
      {
        List<TokenTree> tokenTreeList = generateFeatureTreeTokenFromRequireStList(requireTokenList);
        for(TokenTree tree: tokenTreeList)
        createFeatureModelSegment(sourceFeatureLeaf,tree,isSubFeature);
        // TO Do: add tree for the feature model : Done
        // To Do: not and opt implementaion 
        // TO Do:  1..3 of {A, B, C} : Done 
      }
    
    }
  }
  /*
  this method generates a new feature and links it with a source feature based on its token in the TokenTree.
  It return null if either treeNode or source feature is null.
  */
  public FeatureNode createTargetFeature(TokenTree treeNode, FeatureNode sourceFeature, boolean isSubFeature)
  {
    if (treeNode == null || sourceFeature == null)
    return null; // To Do : should raise error here 
    FeatureNode newFeatureNode = new FeatureNode(model.getFeatureModel());
    newFeatureNode.setName(treeNode.getNodeToken().getName());
    FeatureLink edge = new FeatureLink();
    edge.setFeatureConnectingOpType(treeNode.getFeatureConnectionOpType());
    edge.setSourceFeature(sourceFeature);
    edge.setIsSub(isSubFeature);
    edge.addTargetFeature(newFeatureNode); 
    edge.setFeatureModel(model.getFeatureModel());
    model.getFeatureModel().addFeaturelink(edge);
    return newFeatureNode;
  }
  /*
  This method takes a require-st as a token tree and then it generates its segment in the feature model 
  */
  public void createFeatureModelSegment(FeatureNode sourceFeature, TokenTree tokenTree, boolean isSubFeature)
  {
    Token node = tokenTree.getNodeToken();
    TokenTree linkingParent = tokenTree.getParentTokenTree();
    FeatureLink edge = null;
    if(! tokenTree.getIsLinkingOperator())
    {
      if(node.is("opt") || node.is("not"))
      {
        if(tokenTree.getRightTokenTree().getNodeToken().is("requireTerminal"))
        {
          Mixset targetMixset = new Mixset(tokenTree.getRightTokenTree().getNodeToken().getSubToken("targetMixsetName").getValue());
          FeatureLeaf targetFeature = new FeatureLeaf(model.getFeatureModel());
          targetFeature.setMixsetOrFileNode(targetMixset);
          edge = new FeatureLink();
          edge.setFeatureConnectingOpType(tokenTree.getFeatureConnectionOpType());
          edge.setSourceFeature(sourceFeature);
          edge.addTargetFeature(targetFeature);
          edge.setIsSub(isSubFeature);
          model.getFeatureModel().addFeaturelink(edge);          
        }
      }
      if(node.is("requireTerminal") && node.getSubToken("lowerBound") == null)
      {        	
        //Mixset targetMixset = model.getMixset(node.getSubToken("targetMixsetName").getValue());
        //if(targetMixset == null)
        //return; // To Do: should raise warning 
        Mixset targetMixset = new Mixset(node.getSubToken("targetMixsetName").getValue());
        FeatureLeaf targetFeature = new FeatureLeaf(model.getFeatureModel());
        targetFeature.setMixsetOrFileNode(targetMixset);
        edge = new FeatureLink();
        
        if(linkingParent.getNodeToken().is("ROOT"))
        edge.setFeatureConnectingOpType(FeatureLink.FeatureConnectingOpType.Include);
        else // this is for leaf node as the parent is not null 
        edge.setFeatureConnectingOpType(linkingParent.getFeatureConnectionOpType());
        
        edge.setSourceFeature(sourceFeature);       
        edge.addTargetFeature(targetFeature);
        edge.setIsSub(isSubFeature);
        model.getFeatureModel().addFeaturelink(edge);
      }
      else if(node.is("requireTerminal") && node.getSubToken("lowerBound") != null) //  [lowerBound]..[upperBound] of [A, B, ... ]
      {
        edge = new MultiplicityFeatureConnectingOpType();
		    Multiplicity featureLinkMultiplicity = ((MultiplicityFeatureConnectingOpType) edge).getMultiplicity();
        featureLinkMultiplicity.setRange(node.getSubToken("lowerBound").getValue(), node.getSubToken("upperBound").getValue());
        for(Token subToken : node.getSubTokens())
        {
          if(subToken.is("targetMixsetName"))
          {
            FeatureLeaf targetFeature = new FeatureLeaf(model.getFeatureModel());
            Mixset targetMixset = new Mixset(subToken.getValue()); //To Do: check if its a mixset.
            targetFeature.setMixsetOrFileNode(targetMixset);
            edge.addTargetFeature(targetFeature);
          }
        }
        edge.setSourceFeature(sourceFeature);       
        edge.setIsSub(isSubFeature);
        model.getFeatureModel().addFeaturelink(edge);
      } 
 
    }
    else 
    {
        TokenTree rightTokenTree = tokenTree.getRightTokenTree();
        TokenTree leftTokenTree = tokenTree.getLeftTokenTree();
        if (rightTokenTree == null || leftTokenTree == null)
        return; //To Do: raise error since a connection node does not have left or right node 
        //else 
        FeatureNode intermediateFeatureNode = null;
        boolean parentTokenEqualsCurrentNodeToken = node.is(linkingParent.getNodeToken().getName());
        if (!parentTokenEqualsCurrentNodeToken)
        {
          intermediateFeatureNode = createTargetFeature(tokenTree, sourceFeature, isSubFeature);
          createFeatureModelSegment(intermediateFeatureNode,rightTokenTree,isSubFeature);
          createFeatureModelSegment(intermediateFeatureNode,leftTokenTree,isSubFeature);
        }
        else 
        {
          createFeatureModelSegment(sourceFeature,rightTokenTree,isSubFeature);
          createFeatureModelSegment(sourceFeature,leftTokenTree,isSubFeature);
        }

    }
  }
  /*
  This method filters unwanted tokens & changes the form of require-statement argument from 
  nested tokens, as the parser does, to list of tokens.  
  */
  public ArrayList<Token> getRequireStatementTokensAsList(Token requireStatementToken, List<String> acceptedTokensList)
  {
    ArrayList<Token> TokenList =  new ArrayList<Token>();
    Token terminal;
    for(Token innerToken : requireStatementToken.getSubTokens())
    {
      if (! innerToken.getName().equals("") && acceptedTokensList.contains(innerToken.getName()))
      {
        TokenList.add(innerToken);
      }
      else if (innerToken.getSubTokens() != null)
      	TokenList.addAll(getRequireStatementTokensAsList(innerToken,acceptedTokensList)); // this to obtain [and] out of [requireLinkingOp] 
    }
    return TokenList;
  }
  
  /*
  This methods returns the mixset in which require-statement was found.
  It returns null if the require-statement is in a file (not inside a mixset). 
	*/
  private Mixset getMixsetFromToken(Token token) {
  	Token parentToken = token.getParentToken();
  	if (parentToken.is("mixsetDefinition"))
  	  return model.getMixset(parentToken.getValue());
  	
  	return null;
	}

/*
This method parses req-statement argument & generates a binary tree representation form the req-statment argument.
//It returns one node (root node) if there is no argument to parse.
*/
private ArrayList<TokenTree> generateFeatureTreeTokenFromRequireStList(ArrayList<Token> tokenList)
{
  TokenTree rootTokenTree = new TokenTree(new Token("ROOT",""));
  TokenTree currentTree = rootTokenTree;		
  List<String> linkingOpList = Arrays.asList("and","or","xor");
	ArrayList<TokenTree> tokenTreeList = new ArrayList<TokenTree>();
  
  for (int i=0;i<tokenList.size();i++)
  {
    Token token = tokenList.get(i);
    TokenTree rightTokenTree = new TokenTree(token);
    //Start(1): put each [opt/not][terminal] in a separate TokenTree if it was preceded with [terminal]
    if(token.is("opt") || token.is("not"))
    {
      if(currentTree.getNodeToken().is("requireTerminal") && tokenList.get(i+1).is("requireTerminal")) // A opt B
      {
        rightTokenTree.setRightTokenTree(new TokenTree(tokenList.get(i+1)));
        // setParent to rightTokenTree
        tokenTreeList.add(rightTokenTree);
        i++; //skip opt terminal 
        continue;
      }
    }
    //End(1)
    if(linkingOpList.contains(token.getName()))
    rightTokenTree.setIsLinkingOperator(true);
    currentTree.setRightTokenTree(rightTokenTree);
    rightTokenTree.setParentTokenTree(currentTree);
    currentTree = rightTokenTree;
  }
  currentTree = rootTokenTree.getRightTokenTree(); //currentTree points to the first node of the tree
  
  TokenTree previousLinkingSubTokenTree = null; 
		
  while(currentTree.getRightTokenTree() != null)
 	{
		TokenTree rightLinkingTokenTree = currentTree.getRightTokenTree(); //linking operator on the right of current node 	
    if(rightLinkingTokenTree == null)
    break;
    if(currentTree.getNodeToken() == null || currentTree.getNodeToken().getName() == null ) 
     continue;
    // currentTree.getNodeToken().getName().equals("targetMixsetName") or opt / not
    if(currentTree.getNodeToken().is("requireTerminal") && rightLinkingTokenTree.getIsLinkingOperator())
    {
		// A and B --> (and A B)
    	if (previousLinkingSubTokenTree == null)
      {
      	currentTree.setParentTokenTree(rightLinkingTokenTree);
        rightLinkingTokenTree.setLeftTokenTree(currentTree);
        rightLinkingTokenTree.setParentTokenTree(rootTokenTree);
        rootTokenTree.setRightTokenTree(rightLinkingTokenTree);
        previousLinkingSubTokenTree = rightLinkingTokenTree;
      }
      else
	    {
		    /*
				this for the case : A and B or C --> (or (and A B))
		    */
		    if(previousLinkingSubTokenTree.getPriority() >= rightLinkingTokenTree.getPriority())
		    { 
		    	TokenTree linkNodeToReplace = previousLinkingSubTokenTree;
		      while(linkNodeToReplace != null && ! linkNodeToReplace.getNodeToken().getName().equals("ROOT") )
		      {
		      	if (linkNodeToReplace.getPriority() >= rightLinkingTokenTree.getPriority() )
		        {
							previousLinkingSubTokenTree = linkNodeToReplace;
		        }
						linkNodeToReplace = linkNodeToReplace.getParentTokenTree();
		      }
		      rightLinkingTokenTree.setLeftTokenTree(previousLinkingSubTokenTree);
          rightLinkingTokenTree.setParentTokenTree(previousLinkingSubTokenTree.getParentTokenTree());
		      previousLinkingSubTokenTree.getParentTokenTree().setRightTokenTree(rightLinkingTokenTree); 
		      previousLinkingSubTokenTree.setParentTokenTree(rightLinkingTokenTree);
		      previousLinkingSubTokenTree=rightLinkingTokenTree;	
		    }
		    else
			  {
					/*
		    	this for the case : A or B and C --> or (and A B)
		    	*/
		    	rightLinkingTokenTree.setLeftTokenTree(currentTree);
					rightLinkingTokenTree.setParentTokenTree(previousLinkingSubTokenTree);
			  	previousLinkingSubTokenTree.setRightTokenTree(rightLinkingTokenTree);
		      previousLinkingSubTokenTree = rightLinkingTokenTree;
		    }
		  }
    	// last step: set right node of terminal to null 
    	currentTree.setRightTokenTree(null);
  		}
  	currentTree = rightLinkingTokenTree; // move to next node of the tree 
		}
  tokenTreeList.add(rootTokenTree.getRightTokenTree());
	return tokenTreeList;	
	}

}


/*
This class used to represent the binary tree of require-statement argument 
Ex: require [A and B or C] will be formed as: 
          ... or...  
   ... and...      C
  A           B    
*/
class TokenTree
{
  depend cruise.umple.parser.Token;
  Token nodeToken;
  lazy TokenTree parentTokenTree;
  lazy TokenTree leftTokenTree;
  lazy TokenTree rightTokenTree;
  
  boolean isNegated =false;
  boolean isOpt = false;
  boolean isLinkingOperator = false;
/*
This method selects the the connection operator type based on the type of the (linking) token.
If the type is not specified for the linking node, The default is Required.
It returns null if the node is termainl node.
*/
public FeatureLink.FeatureConnectingOpType getFeatureConnectionOpType()
{
  if(nodeToken != null )
  {
    String operator = nodeToken.getName();
    switch (operator) {
      case "and":
        return FeatureLink.FeatureConnectingOpType.Conjunctive;
      case "or":
        return FeatureLink.FeatureConnectingOpType.Disjunctive;
      case "xor":
        return FeatureLink.FeatureConnectingOpType.XOR;
      case "multiplicityTerminal":
        return FeatureLink.FeatureConnectingOpType.Multiplicity;
      case "opt":
        return FeatureLink.FeatureConnectingOpType.Optional;
      case "not":
        return FeatureLink.FeatureConnectingOpType.Exclude;
      default:
        return FeatureLink.FeatureConnectingOpType.Required;
     }
  }

  return null;
}
/*
This methods returens the priority of a node to move down in the binary tree.
high priority node moves down & low prioriy moves up 
not > and > xor > or > ROOT (Top of the tree)
*/
  public int getPriority()
  {
    String tokenName = nodeToken.getName();
    switch (tokenName)
    {
      case "and":
      return 3;
      case "xor":
      return 2;
      case "or":
      return 1;
      case "ROOT":
      return 0;
    }
    return -1; // lower priority, leaf nodes should not move 
  }

}
