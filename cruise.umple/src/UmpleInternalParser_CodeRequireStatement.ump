/*
Copyright: All contributers to the Umple Project.

This file is made available subject to the open source license found at:
http://umple.org/license

This file analyzses require statement tokens to populate Requiregraph for Umple model.

Please refer to UmpleInternalParser.ump for more details.
*/

class UmpleInternalParser
{
  depend cruise.umple.compiler.*;
  public void analyzeRequireStatement(Token t, int analysisStep)
  {
    if (analysisStep != 2)
    {
      shouldProcessAgain = shouldProcessAgain || (analysisStep == 1);
      return;
    }    
    if (t.is("requireStatement"))
    {
      FeatureModel featureModel = model.getFeatureModel();
      if(featureModel == null)
        featureModel = new FeatureModel("featureModel");
      featureModel.setUmpleModel(model);

      Mixset sourceMixset = getMixsetFromToken(t);
      FeatureLeaf sourceFeatureLeaf = new FeatureLeaf(featureModel);
      // require-statement comes from umple file or mixset ?
      if (sourceMixset == null) 
      sourceFeatureLeaf.setMixsetOrFileNode(new UmpleFile(t.getPosition().getFilename()));
      else 
      sourceFeatureLeaf.setMixsetOrFileNode(sourceMixset);
      
      boolean isSubFeature = t.getSubToken("subfeature") != null; 

       //tokens needed for parsing require-statement
     // List<String> acceptedTokensList = Arrays.asList("targetMixsetName","lowerBound","upperBound","and","not","xor","or","subfeature","opt");
           List<String> acceptedTokensList = Arrays.asList("targetMixsetName","and","not","xor","or","opt");

      ArrayList<Token> requireTokenList = getRequireStatementTokensAsList(t, acceptedTokensList);      
      if(requireTokenList.size() == 0 )
      return;

      for(Token token : requireTokenList)
      {
        if ( requireTokenList.size() == 2 ) // need more checking
         {
          if(token.is("targetMixsetName"))
          {        	
            Mixset targetMixset = model.getMixset(token.getValue());
            if(targetMixset == null)
              return;
            FeatureLeaf targetFeature = new FeatureLeaf(featureModel);
            targetFeature.setMixsetOrFileNode(targetMixset);
            FeatureLink edge = new FeatureLink(FeatureLink.FeatureConnectingOpType.Include, sourceFeatureLeaf);        	
            edge.addTargetFeature(targetFeature);
            edge.setIsSub(isSubFeature);

          }
          break; // then stop the loop
        }



      }
      TokenTree tree = getFeatureTreeTokenFromRequireStList(requireTokenList);       

    }
    
  }
  

  /*
  This methods clean unwanted tokens & changes the form of require-statement argument from 
  nested tokens, as the parser does, to list of tokens.  
  */
  public ArrayList<Token> getRequireStatementTokensAsList(Token requireStatementToken, List<String> acceptedTokensList)
  {
    ArrayList<Token> TokenList =  new ArrayList<Token>();
    for(Token innerToken : requireStatementToken.getSubTokens())
    {
      if (! innerToken.getName().equals("") && acceptedTokensList.contains(innerToken.getName()))
      {
        TokenList.add(innerToken);
      }
      else if (innerToken.getSubTokens() != null)
      	TokenList.addAll(getRequireStatementTokensAsList(innerToken,acceptedTokensList)); 
    }
    return TokenList;
  }
  
  /*
  This methods returns the mixset in which require-statement was found.
  It returns null if the require-statement is in a file (not inside a mixset). 
	*/
  private Mixset getMixsetFromToken(Token token) {
  	Token parentToken = token.getParentToken();
  	if (parentToken.is("mixsetDefinition"))
  	  return model.getMixset(parentToken.getValue());
  	
  	return null;
	}

private TokenTree getFeatureTreeTokenFromRequireStList(ArrayList<Token> tokenList)
{
	TokenTree rootTokenTree = new TokenTree();
  rootTokenTree.setNodeToken(new Token("ROOT",""));
	TokenTree currentTree = rootTokenTree;		
  List<String> acceptedTokensList = Arrays.asList("and","or","xor");
	for(Token token : tokenList)
	{
		TokenTree rightTokenTree = new TokenTree();
		rightTokenTree.setNodeToken(token);
    if(acceptedTokensList.contains(token.getName()))
    rightTokenTree.setIsLinkingOperator(true);
		currentTree.setRightTokenTree(rightTokenTree);
    //rightTokenTree.setParentTokenTree(currentTree);
		currentTree = rightTokenTree;
	}
	
	currentTree = rootTokenTree.getRightTokenTree(); //currentTree points to the first node of the tree
	
  TokenTree previousLinkingSubTokenTree = null;
  TokenTree rootNode = null;
	
  while(currentTree.getRightTokenTree() != null)
	{
		TokenTree rightLinkingTokenTree = currentTree.getRightTokenTree();
		
		if(rightLinkingTokenTree == null)
			break;
    if(currentTree.getNodeToken() == null || currentTree.getNodeToken().getName() == null ) 
     continue;
     // currentTree.getNodeToken().getName().equals("targetMixsetName") or opt / not
		if(currentTree.getNodeToken().getName().equals("targetMixsetName") && rightLinkingTokenTree.getIsLinkingOperator())
		{
      // A and B --> and A B
			if (previousLinkingSubTokenTree == null)
			{
        currentTree.setRightTokenTree(null);
        currentTree.setParentTokenTree(rightLinkingTokenTree);
        rightLinkingTokenTree.setLeftTokenTree(currentTree);
        rightLinkingTokenTree.setParentTokenTree(rootTokenTree);
        previousLinkingSubTokenTree = rightLinkingTokenTree;
        rootNode = rightLinkingTokenTree;// this is the root node 
			}
			else if(previousLinkingSubTokenTree != null )
			{
        /*
             this for the case : A and B or C --> or (and A B)
             and.getPriority == 0. or.getPriority ==1
        */
				if(previousLinkingSubTokenTree.getPriority() <= rightLinkingTokenTree.getPriority())
				{ 
         // if(previousLinkingSubTokenTree.getLeftTokenTree() != null)
          //{            
            
            TokenTree tt = previousLinkingSubTokenTree;
            while(tt != null && ! tt.getNodeToken().getName().equals("ROOT") )
            {
              if (tt.getPriority() <= rightLinkingTokenTree.getPriority() )
               {
                previousLinkingSubTokenTree = tt;
               }
               tt = tt.getParentTokenTree();
            }

          rightLinkingTokenTree.setLeftTokenTree(previousLinkingSubTokenTree);
          previousLinkingSubTokenTree.getParentTokenTree().setRightTokenTree(rightLinkingTokenTree); 
          previousLinkingSubTokenTree.setParentTokenTree(rightLinkingTokenTree);
          currentTree.setRightTokenTree(null);
          previousLinkingSubTokenTree=rightLinkingTokenTree;
          
         /* }
          else 
          {
            rightLinkingTokenTree.setLeftTokenTree(currentTree);
            previousLinkingSubTokenTree.setRightTokenTree(rightLinkingTokenTree);
            rightLinkingTokenTree.setParentTokenTree(previousLinkingSubTokenTree);
            rootNode = rightLinkingTokenTree;
          }*/	
				}
				else
				{   /*
             this for the case : A or B and C --> or (and A B)
             and.getPriority == 0. or.getPriority ==1
            */
          // last node has low priori
          rootNode = previousLinkingSubTokenTree;
          currentTree.setRightTokenTree(null);
          rightLinkingTokenTree.setLeftTokenTree(currentTree);
          rightLinkingTokenTree.setParentTokenTree(previousLinkingSubTokenTree);
        	previousLinkingSubTokenTree.setRightTokenTree(rightLinkingTokenTree);
				}
			}
			
		}
    
  //  if (currentTree.getIsLinkingOperator())
   // {
   //   previousLinkingSubTokenTree = currentTree;
   // }
		currentTree = rightLinkingTokenTree; // move to next node 
	}
  
	return rootTokenTree;	
}

}


/*
This class used to represent the binary tree of require-statement
*/

class TokenTree
{
  depend cruise.umple.parser.Token;
	lazy Token nodeToken;
  lazy TokenTree parentTokenTree;
	lazy TokenTree leftTokenTree;
	lazy TokenTree rightTokenTree;
  
  boolean isNegated =false;
  boolean isOpt = false;
  boolean isLinkingOperator = false;
  public int getPriority()
  {
    String tokenName = nodeToken.getName();
    switch (tokenName)
    {
      case "and":
      return 0;
      case "or":
      return 1;
      case "xor":
      return 2;
      case "ROOT":
      return 3;
    }
    return -1;
  }
}