/*
Copyright: All contributers to the Umple Project.

This file is made available subject to the open source license found at:
http://umple.org/license

This file analyzses require statement tokens to populate Requiregraph for Umple model.

Please refer to UmpleInternalParser.ump for more details.
*/

class UmpleInternalParser
{
  depend cruise.umple.compiler.*;
  public void analyzeRequireStatement(Token t, int analysisStep)
  {
    if (analysisStep != 2)
    {
      shouldProcessAgain = shouldProcessAgain || (analysisStep == 1);
      return;
    }    
    if (t.is("requireStatement"))
    {
      FeatureModel featureModel = model.getFeatureModel();
      if(featureModel == null)
        featureModel = new FeatureModel("featureModel");
      featureModel.setUmpleModel(model);

      FeatureLeaf sourceFeatureLeaf;
      Mixset sourceMixset = getMixsetFromToken(t);
      if(sourceMixset != null)
      {
        sourceFeatureLeaf = featureModel.getOrCreateFeatureLeafNode(sourceMixset.getName());
        sourceFeatureLeaf.setMixsetOrFileNode(sourceMixset); 
      }
      else
      {
        UmpleFile ufile = new UmpleFile(t.getPosition().getFilename());
        sourceFeatureLeaf = featureModel.getOrCreateFeatureLeafNode(ufile.getName()); 
        sourceFeatureLeaf.setMixsetOrFileNode(ufile);
      }
    
      boolean isSubFeature = t.getSubToken("subfeature") != null; 

       //tokens needed for parsing require-statement
      List<String> acceptedTokensList = Arrays.asList("requireTerminal","and","not","xor","or","opt");
      ArrayList<Token> requireTokenList = getRequireStatementTokensAsList(t, acceptedTokensList);      
      Token firstTokenOfRequireTokenList;

      if(requireTokenList.size() == 0 ) // require [ ]
      return;

      if (requireTokenList.size() >= 1)  // has the form of : require [A and B or C .... ]
      {
        List<TokenTree> tokenTreeList = generateFeatureTreeTokenFromRequireStList(requireTokenList);
        for(TokenTree tree: tokenTreeList)
        createFeatureModelSegment(sourceFeatureLeaf,tree,isSubFeature);
        
        //
        // TO Do: add tree for the feature model : Done
        // To Do: not and opt implementaion 
        // TO Do:  1..3 of {A, B, C} : Done 
      }
    
    }
  }  
  /*
  this method generates a new feature and links it with a source feature based on its token in the TokenTree.
  It return null if either treeNode or source feature is null.
  */
  public FeatureNode createTargetFeature(TokenTree treeNode, FeatureNode sourceFeature, boolean isSubFeature)
  {
    if (treeNode == null || sourceFeature == null)
    return null; // To Do : should raise error here 
    FeatureNode newFeatureNode = new FeatureNode(model.getFeatureModel());
    newFeatureNode.setName(treeNode.getNodeToken().getName());
    FeatureLink edge = new FeatureLink();
    edge.setFeatureConnectingOpType(treeNode.getFeatureConnectionOpType());
    edge.setSourceFeature(sourceFeature);
    edge.setIsSub(isSubFeature);
    edge.addTargetFeature(newFeatureNode); 
    edge.setFeatureModel(model.getFeatureModel());
    model.getFeatureModel().addFeaturelink(edge);
    return newFeatureNode;
  }
  /*
  This method takes a require-st as a token tree and then it generates its segment in the feature model 
  */
  public void createFeatureModelSegment(FeatureNode sourceFeature, TokenTree tokenTree, boolean isSubFeature)
  {
    Token node = tokenTree.getNodeToken();
    TokenTree linkingParent = tokenTree.getParentTokenTree();
    FeatureLink edge = null;
    FeatureModel featureModel = model.getFeatureModel();
    if(! tokenTree.getIsLinkingOperator())
    {
      if(node.is("opt") || node.is("not"))
      {
        if(tokenTree.getRightTokenTree().getNodeToken().is("requireTerminal"))
        {
          Mixset targetMixset = new Mixset(tokenTree.getRightTokenTree().getNodeToken().getSubToken("targetMixsetName").getValue());
          FeatureLeaf targetFeature = featureModel.getOrCreateFeatureLeafNode(targetMixset.getName()); 
          targetFeature.setMixsetOrFileNode(targetMixset);
          edge = new FeatureLink();
          edge.setFeatureConnectingOpType(tokenTree.getFeatureConnectionOpType());
          edge.setSourceFeature(sourceFeature);
          edge.addTargetFeature(targetFeature);
          edge.setIsSub(isSubFeature);
          model.getFeatureModel().addFeaturelink(edge);          
        }
      }
      if(node.is("requireTerminal") && node.getSubToken("lowerBound") == null)
      {        	
        //Mixset targetMixset = model.getMixset(node.getSubToken("targetMixsetName").getValue());
        //if(targetMixset == null)
        //return; // To Do: should raise warning 
        Mixset targetMixset = new Mixset(node.getSubToken("targetMixsetName").getValue());
        FeatureLeaf targetFeature = featureModel.getOrCreateFeatureLeafNode(targetMixset.getName()); 
        targetFeature.setMixsetOrFileNode(targetMixset);
        //targetFeature.setName(targetMixset.getName());
        edge = new FeatureLink();
        
        if(linkingParent.getNodeToken().is("ROOT"))
        edge.setFeatureConnectingOpType(FeatureLink.FeatureConnectingOpType.Include);
        else // this is for leaf node as the parent is not null 
        edge.setFeatureConnectingOpType(linkingParent.getFeatureConnectionOpType());
        
        edge.setSourceFeature(sourceFeature);       
        edge.addTargetFeature(targetFeature);
        edge.setIsSub(isSubFeature);
        model.getFeatureModel().addFeaturelink(edge);
      }
      else if(node.is("requireTerminal") && node.getSubToken("lowerBound") != null) //  [lowerBound]..[upperBound] of [A, B, ... ]
      {
        edge = new MultiplicityFeatureConnectingOpType();
		    Multiplicity featureLinkMultiplicity = ((MultiplicityFeatureConnectingOpType) edge).getMultiplicity();
        featureLinkMultiplicity.setRange(node.getSubToken("lowerBound").getValue(), node.getSubToken("upperBound").getValue());
        for(Token subToken : node.getSubTokens())
        {
          if(subToken.is("targetMixsetName"))
          {
            Mixset targetMixset = new Mixset(subToken.getValue()); //To Do: check if its a mixset.
            FeatureLeaf targetFeature = featureModel.getOrCreateFeatureLeafNode(targetMixset.getName()); 
            targetFeature.setMixsetOrFileNode(targetMixset);
            edge.addTargetFeature(targetFeature);
          }
        }
        edge.setSourceFeature(sourceFeature);       
        edge.setIsSub(isSubFeature);
        model.getFeatureModel().addFeaturelink(edge);
      } 
 
    }
    else 
    {
        TokenTree rightTokenTree = tokenTree.getRightTokenTree();
        TokenTree leftTokenTree = tokenTree.getLeftTokenTree();
        if (rightTokenTree == null || leftTokenTree == null)
        return; //To Do: raise error since a connection node does not have left or right node 
        //else 
        FeatureNode intermediateFeatureNode = null;
        boolean parentTokenEqualsCurrentNodeToken = node.is(linkingParent.getNodeToken().getName());
        if (!parentTokenEqualsCurrentNodeToken)
        {
          intermediateFeatureNode = createTargetFeature(tokenTree, sourceFeature, isSubFeature);
          createFeatureModelSegment(intermediateFeatureNode,rightTokenTree,isSubFeature);
          createFeatureModelSegment(intermediateFeatureNode,leftTokenTree,isSubFeature);
        }
        else 
        {
          createFeatureModelSegment(sourceFeature,rightTokenTree,isSubFeature);
          createFeatureModelSegment(sourceFeature,leftTokenTree,isSubFeature);
        }

    }
  }
  /*
  This method filters unwanted tokens & changes the form of require-statement argument from 
  nested tokens, as the parser does, to list of tokens.  
  */
  public ArrayList<Token> getRequireStatementTokensAsList(Token requireStatementToken, List<String> acceptedTokensList)
  {
    ArrayList<Token> TokenList =  new ArrayList<Token>();
    Token terminal;
    for(Token innerToken : requireStatementToken.getSubTokens())
    {
      if (! innerToken.getName().equals("") && acceptedTokensList.contains(innerToken.getName()))
      {
        TokenList.add(innerToken);
      }
      else if (innerToken.getSubTokens() != null)
      	TokenList.addAll(getRequireStatementTokensAsList(innerToken,acceptedTokensList)); // this to obtain [and] out of [requireLinkingOp] 
    }
    return TokenList;
  }
  
  /*
  This methods returns the mixset in which require-statement was found.
  It returns null if the require-statement is in a file (not inside a mixset). 
	*/
  private Mixset getMixsetFromToken(Token token) {
  	Token parentToken = token.getParentToken();
  	if (parentToken.is("mixsetDefinition"))
  	  return model.getMixset(parentToken.getValue());
  	
  	return null;
	}

/*
This method parses req-statement argument & generates a binary tree representation form the req-statment argument.
//It returns one node (root node) if there is no argument to parse.
*/
private ArrayList<TokenTree> generateFeatureTreeTokenFromRequireStList(ArrayList<Token> tokenList)
{
  TokenTree rootTokenTree = new TokenTree(new Token("ROOT",""));
  TokenTree currentTree = rootTokenTree;		
  List<String> linkingOpList = Arrays.asList("and","or","xor");
	ArrayList<TokenTree> tokenTreeList = new ArrayList<TokenTree>();
  
  for (int i=0;i<tokenList.size();i++)
  {
    Token token = tokenList.get(i);
    TokenTree rightTokenTree = new TokenTree(token);
    //Start(1): put each [opt/not][terminal] in a separate TokenTree if it was preceded with [terminal]
    if(token.is("opt") || token.is("not"))
    {
      if(currentTree.getNodeToken().is("requireTerminal") && tokenList.get(i+1).is("requireTerminal")) // A opt B
      {
        rightTokenTree.setRightTokenTree(new TokenTree(tokenList.get(i+1)));
        // setParent to rightTokenTree
        tokenTreeList.add(rightTokenTree);
        i++; //skip opt terminal 
        continue;
      }
    }
    //End(1)
    if(linkingOpList.contains(token.getName()))
    rightTokenTree.setIsLinkingOperator(true);
    currentTree.setRightTokenTree(rightTokenTree);
    rightTokenTree.setParentTokenTree(currentTree);
    currentTree = rightTokenTree;
  }
  currentTree = rootTokenTree.getRightTokenTree(); //currentTree points to the first node of the tree
  
  TokenTree previousLinkingSubTokenTree = null; 
		
  while(currentTree.getRightTokenTree() != null)
 	{
		TokenTree rightLinkingTokenTree = currentTree.getRightTokenTree(); //linking operator on the right of current node 	
    if(rightLinkingTokenTree == null)
    break;
    if(currentTree.getNodeToken() == null || currentTree.getNodeToken().getName() == null ) 
     continue;
    if(currentTree.getNodeToken().is("requireTerminal") && rightLinkingTokenTree.getIsLinkingOperator())
    {
		// A and B --> (and A B)
    	if (previousLinkingSubTokenTree == null)
      {
      	currentTree.setParentTokenTree(rightLinkingTokenTree);
        rightLinkingTokenTree.setLeftTokenTree(currentTree);
        rightLinkingTokenTree.setParentTokenTree(rootTokenTree);
        rootTokenTree.setRightTokenTree(rightLinkingTokenTree);
        previousLinkingSubTokenTree = rightLinkingTokenTree;
      }
      else
	    {
		    /*
				this for the case : A and B or C --> (or (and A B))
		    */
		    if(previousLinkingSubTokenTree.getPriority() >= rightLinkingTokenTree.getPriority())
		    { 
		    	TokenTree linkNodeToReplace = previousLinkingSubTokenTree;
		      while(linkNodeToReplace != null && ! linkNodeToReplace.getNodeToken().getName().equals("ROOT") )
		      {
		      	if (linkNodeToReplace.getPriority() >= rightLinkingTokenTree.getPriority() )
		        {
							previousLinkingSubTokenTree = linkNodeToReplace;
		        }
						linkNodeToReplace = linkNodeToReplace.getParentTokenTree();
		      }
		      rightLinkingTokenTree.setLeftTokenTree(previousLinkingSubTokenTree);
          rightLinkingTokenTree.setParentTokenTree(previousLinkingSubTokenTree.getParentTokenTree());
		      previousLinkingSubTokenTree.getParentTokenTree().setRightTokenTree(rightLinkingTokenTree); 
		      previousLinkingSubTokenTree.setParentTokenTree(rightLinkingTokenTree);
		      previousLinkingSubTokenTree=rightLinkingTokenTree;	
		    }
		    else
			  {
					/*
		    	this for the case : A or B and C --> or (and A B)
		    	*/
		    	rightLinkingTokenTree.setLeftTokenTree(currentTree);
					rightLinkingTokenTree.setParentTokenTree(previousLinkingSubTokenTree);
			  	previousLinkingSubTokenTree.setRightTokenTree(rightLinkingTokenTree);
		      previousLinkingSubTokenTree = rightLinkingTokenTree;
		    }
		  }
    	// last step: set right node of terminal to null 
    	currentTree.setRightTokenTree(null);
  		}
  	currentTree = rightLinkingTokenTree; // move to next node of the tree 
		}
  tokenTreeList.add(rootTokenTree.getRightTokenTree());
	return tokenTreeList;	
	}

  public void analyzeFeatureModel()
  {
    if(model.getFeatureModel() != null)
    model.getFeatureModel().satisfyFeatureModel();
  }
}


class FeatureModel{
  depend java.util.stream.*;
/*
 * This method returns a leaf node from FeatureModel based on its name.
 * return null if the leaf node is not found.   
 */
  public FeatureLeaf getFeatureLeafNode(String name)
  {
    for(FeatureNode aNode: node)
    {
      if(aNode.getName().equals(name) && aNode.getIsLeaf()) // isLeaf
      return ((FeatureLeaf) aNode);
    }
    return null;
  }
  /*
  This method does conditional addition for a FeatureLeaf based on the provided name. 
  It returns a new FeatureLeaf if its not found, or existing FeatureLeaf if the name was found.
  */
  public FeatureLeaf getOrCreateFeatureLeafNode(String name)
  {
    FeatureLeaf aNode = getFeatureLeafNode(name);
    if(aNode == null)
    {
      aNode = new FeatureLeaf(this);
      aNode.setName(name);
    }
    return aNode; 
  }
  /*
  This method returns true if the feature leaf has a use-statement.
  It returns false if there is no use-statement for the mixset.
  It returns false if there is no mixset or file in the feature leaf.
  */
  public boolean isUsedFeatureLeaf(FeatureLeaf featureLeaf){
    boolean isMixset = featureLeaf.getMixsetOrFileNode().getIsMixset();
    if(isMixset)
    {
      Mixset mixset = getUmpleModel().getMixset(featureLeaf.getMixsetOrFileNode().getName());
      if(mixset != null)
      {
        if(mixset.getUseUmpleFile() != null)
        return true;  // this means there is a use-statement here
        //else there is no use-statement    
      }
      else 
      {
        return false;//there is no mixset with the specified name. 
      }
    }
    return false; 
  }
  /*
  This method takes a feature link (from the feature model) and decides whether the link is satisfied.
  If the link is not satisfied, it return false.
  Ex: the link "source--> and" for M1 and M2 is true if there are use-statements for both M1 and M2.   
  */
  public boolean evaluateFeatureLink(FeatureLink featureLink)
  {
    FeatureNode featureNode = ((FeatureNode) featureLink.getTargetFeature(0));
    if(featureNode.getIsLeaf())
    {
      if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Include))
      {
        return isUsedFeatureLeaf((FeatureLeaf)featureNode);
      } 
      else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Exclude))
      {
        return !isUsedFeatureLeaf((FeatureLeaf)featureNode); // return true when there is no use-statement, or no def for mixset 
      }
      else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Optional))
      {
        return true;        // opt is allawys has a true value 
      }
      else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Multiplicity))
      {
        MultiplicityFeatureConnectingOpType multiplicityFeatureLink = (MultiplicityFeatureConnectingOpType) featureLink;
        int upperBound = multiplicityFeatureLink.getMultiplicity().getUpperBound();
        int lowerBound = multiplicityFeatureLink.getMultiplicity().getLowerBound();
        List<FeatureNode> featureNodes = featureLink.getTargetFeature();
        int countOfUsedTarget = 0;
        for(int i=0 ; i < featureNodes.size(); i++){
          if(isUsedFeatureLeaf((FeatureLeaf)featureNodes.get(i)))
          countOfUsedTarget++;
        }
        return (countOfUsedTarget <= upperBound && countOfUsedTarget >= lowerBound) ? true: false;    
      }
      else 
      return isUsedFeatureLeaf((FeatureLeaf)featureNode);
    } // if not leaf node
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Conjunctive))
    { 
      if(!featureNode.getIsLeaf())
      {
        List<FeatureLink> outgoingLinks = featureNode.getSourceFeatureLink();
        boolean result = true;
        for(int i=0 ; i<outgoingLinks.size(); i++){
          result = result && evaluateFeatureLink(outgoingLinks.get(i));
        }
        return result;
      }
    }
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Disjunctive))
    {   
      if(!featureNode.getIsLeaf())
      {
        boolean result = false;
        List<FeatureLink> outgoingLinks = featureNode.getSourceFeatureLink();
        for(int i=0 ; i<outgoingLinks.size(); i++){
          result = result || evaluateFeatureLink(outgoingLinks.get(i));
        }
        return result;
      }
    }
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.XOR))
    { 
      if(!featureNode.getIsLeaf())
          {
            List<FeatureLink> outgoingLinks = featureNode.getSourceFeatureLink();
            int countOfUsedTarget = 0;
            for(int i=0 ; i < outgoingLinks.size(); i++){
              if(evaluateFeatureLink(outgoingLinks.get(i)))
              countOfUsedTarget++;
            }
            return (countOfUsedTarget == 1) ? true: false;
          }
    }
    //otherwise
    return false;
  }
  /*
  This method checks whether the use-statements plus the feature model results in valid configuration.
  It return true If there is no feature model.
  */
  public boolean satisfyFeatureModel()
  {
    UmpleModel model = getUmpleModel();
    boolean isSatisfied = true;
    // get root features : has outgoing links but no incoming links
    List <FeatureNode> rootFeatures = getNode().stream().filter(n -> (n.hasSourceFeatureLink() && n.getIsLeaf())).collect(Collectors.toList());
    for(FeatureNode featureNode: rootFeatures)
    {
      List <FeatureLink> featureNodeOutLinks = featureNode.getSourceFeatureLink();
      for(FeatureLink flink : featureNodeOutLinks)
      {
        isSatisfied = isSatisfied && evaluateFeatureLink(flink);
      }
    }
    return isSatisfied;
  }
}
/*
This class used to represent the binary tree of require-statement argument 
Ex: require [A and B or C] will be formed as: 
          ... or...  
   ... and...      C
  A           B    
*/
class TokenTree
{
  depend cruise.umple.parser.Token;
  Token nodeToken;
  lazy TokenTree parentTokenTree;
  lazy TokenTree leftTokenTree;
  lazy TokenTree rightTokenTree;
  
  boolean isNegated =false;
  boolean isOpt = false;
  boolean isLinkingOperator = false;
/*
This method selects the the connection operator type based on the type of the (linking) token.
If the type is not specified for the linking node, The default is Required.
It returns null if the node is termainl node.
*/
public FeatureLink.FeatureConnectingOpType getFeatureConnectionOpType()
{
  if(nodeToken != null )
  {
    String operator = nodeToken.getName();
    switch (operator) {
      case "and":
        return FeatureLink.FeatureConnectingOpType.Conjunctive;
      case "or":
        return FeatureLink.FeatureConnectingOpType.Disjunctive;
      case "xor":
        return FeatureLink.FeatureConnectingOpType.XOR;
      case "multiplicityTerminal":
        return FeatureLink.FeatureConnectingOpType.Multiplicity;
      case "opt":
        return FeatureLink.FeatureConnectingOpType.Optional;
      case "not":
        return FeatureLink.FeatureConnectingOpType.Exclude;
      default:
        return FeatureLink.FeatureConnectingOpType.Required;
     }
  }

  return null;
}
/*
This methods returens the priority of a node to move down in the binary tree.
high priority node moves down & low prioriy moves up 
not > and > xor > or > ROOT (Top of the tree)
*/
  public int getPriority()
  {
    String tokenName = nodeToken.getName();
    switch (tokenName)
    {
      case "and":
      return 3;
      case "xor":
      return 2;
      case "or":
      return 1;
      case "ROOT":
      return 0;
    }
    return -1; // lower priority, leaf nodes should not move 
  }

}
