/*
Copyright: All contributers to the Umple Project.

This file is made available subject to the open source license found at:
http://umple.org/license

This file analyzses require statement tokens to populate Requiregraph for Umple model.

Please refer to UmpleInternalParser.ump for more details.
*/

class UmpleInternalParser
{
  depend cruise.umple.compiler.*;
  public void analyzeRequireStatement(Token t, int analysisStep)
  {
    if (analysisStep != 2)
    {
      shouldProcessAgain = shouldProcessAgain || (analysisStep == 1);
      return;
    }    
    if (t.is("requireStatement"))
    {
      FeatureModel featureModel = model.getFeatureModel();
      if(featureModel == null)
        featureModel = new FeatureModel("featureModel");
      featureModel.setUmpleModel(model);

      FeatureLeaf sourceFeatureLeaf;
      Mixset sourceMixset = getMixsetFromToken(t);
      if(sourceMixset != null)
      {
        sourceFeatureLeaf = featureModel.getOrCreateFeatureLeafNode(sourceMixset.getName());
        sourceFeatureLeaf.setMixsetOrFileNode(sourceMixset); 
      }
      else
      {
        UmpleFile ufile = new UmpleFile(t.getPosition().getFilename());
        sourceFeatureLeaf = featureModel.getOrCreateFeatureLeafNode(ufile.getName()); 
        sourceFeatureLeaf.setMixsetOrFileNode(ufile);
      }
    
      boolean isSubFeature = t.getSubToken("subfeature") != null; 

       //tokens needed for parsing require-statement
      List<String> acceptedTokensList = Arrays.asList("requireTerminal","and","not","xor","or","opt");
      ArrayList<Token> requireTokenList = getRequireStatementTokensAsList(t, acceptedTokensList);      
      Token firstTokenOfRequireTokenList;

      if(requireTokenList.size() == 0 ) // require [ ]
      return;

      if (requireTokenList.size() >= 1)  // has the form of : require [A and B or C .... ]
      {
        List<TokenTree> tokenTreeList = generateFeatureTreeTokenFromRequireStList(requireTokenList);
        for(TokenTree tree: tokenTreeList)
        createFeatureModelSegment(sourceFeatureLeaf,tree,isSubFeature);
        
        //
        // TO Do: add tree for the feature model : Done
        // To Do: not and opt implementaion 
        // TO Do:  1..3 of {A, B, C} : Done 
      }
    
    }
  }  
  /*
  this method generates a new feature and links it with a source feature based on its token in the TokenTree.
  It return null if either treeNode or source feature is null.
  */
  public FeatureNode createTargetFeature(TokenTree treeNode, FeatureNode sourceFeature, boolean isSubFeature)
  {
    if (treeNode == null || sourceFeature == null)
    return null; // To Do : should raise error here 
    FeatureNode newFeatureNode = new FeatureNode(model.getFeatureModel());
    newFeatureNode.setName(treeNode.getNodeToken().getName());
    FeatureLink edge = new FeatureLink();
    edge.setFeatureConnectingOpType(treeNode.getFeatureConnectionOpType());
    edge.setSourceFeature(sourceFeature);
    edge.setIsSub(isSubFeature);
    edge.addTargetFeature(newFeatureNode); 
    edge.setFeatureModel(model.getFeatureModel());
    model.getFeatureModel().addFeaturelink(edge);
    return newFeatureNode;
  }
  /*
  This method takes a require-st as a token tree and then it generates its segment in the feature model 
  */
  public void createFeatureModelSegment(FeatureNode sourceFeature, TokenTree tokenTree, boolean isSubFeature)
  {
    Token node = tokenTree.getNodeToken();
    TokenTree linkingParent = tokenTree.getParentTokenTree();
    FeatureLink edge = null;
    FeatureModel featureModel = model.getFeatureModel();
    if(! tokenTree.getIsLinkingOperator())
    {
      if(node.is("opt") || node.is("not"))
      {
        if(tokenTree.getRightTokenTree().getNodeToken().is("requireTerminal"))
        {
          Mixset targetMixset = new Mixset(tokenTree.getRightTokenTree().getNodeToken().getSubToken("targetMixsetName").getValue());
          FeatureLeaf targetFeature = featureModel.getOrCreateFeatureLeafNode(targetMixset.getName()); 
          targetFeature.setMixsetOrFileNode(targetMixset);
          edge = new FeatureLink();
          edge.setFeatureConnectingOpType(tokenTree.getFeatureConnectionOpType());
          edge.setSourceFeature(sourceFeature);
          edge.addTargetFeature(targetFeature);
          edge.setIsSub(isSubFeature);
          model.getFeatureModel().addFeaturelink(edge);          
        }
      }
      if(node.is("requireTerminal") && node.getSubToken("lowerBound") == null)
      {        	
        //Mixset targetMixset = model.getMixset(node.getSubToken("targetMixsetName").getValue());
        //if(targetMixset == null)
        //return; // To Do: should raise warning 
        Mixset targetMixset = new Mixset(node.getSubToken("targetMixsetName").getValue());
        FeatureLeaf targetFeature = featureModel.getOrCreateFeatureLeafNode(targetMixset.getName()); 
        targetFeature.setMixsetOrFileNode(targetMixset);
        //targetFeature.setName(targetMixset.getName());
        edge = new FeatureLink();
        
        if(linkingParent.getNodeToken().is("ROOT"))
        edge.setFeatureConnectingOpType(FeatureLink.FeatureConnectingOpType.Include);
        else // this is for leaf node as the parent is not null 
        edge.setFeatureConnectingOpType(linkingParent.getFeatureConnectionOpType());
        
        edge.setSourceFeature(sourceFeature);       
        edge.addTargetFeature(targetFeature);
        edge.setIsSub(isSubFeature);
        model.getFeatureModel().addFeaturelink(edge);
      }
      else if(node.is("requireTerminal") && node.getSubToken("lowerBound") != null) //  [lowerBound]..[upperBound] of [A, B, ... ]
      {
        edge = new MultiplicityFeatureConnectingOpType();
		    Multiplicity featureLinkMultiplicity = ((MultiplicityFeatureConnectingOpType) edge).getMultiplicity();
        featureLinkMultiplicity.setRange(node.getSubToken("lowerBound").getValue(), node.getSubToken("upperBound").getValue());
        for(Token subToken : node.getSubTokens())
        {
          if(subToken.is("targetMixsetName"))
          {
            Mixset targetMixset = new Mixset(subToken.getValue()); //To Do: check if its a mixset.
            FeatureLeaf targetFeature = featureModel.getOrCreateFeatureLeafNode(targetMixset.getName()); 
            targetFeature.setMixsetOrFileNode(targetMixset);
            edge.addTargetFeature(targetFeature);
          }
        }
        edge.setSourceFeature(sourceFeature);       
        edge.setIsSub(isSubFeature);
        model.getFeatureModel().addFeaturelink(edge);
      } 
 
    }
    else 
    {
        TokenTree rightTokenTree = tokenTree.getRightTokenTree();
        TokenTree leftTokenTree = tokenTree.getLeftTokenTree();
        if (rightTokenTree == null || leftTokenTree == null)
        return; //To Do: raise error since a connection node does not have left or right node 
        //else 
        FeatureNode intermediateFeatureNode = null;
        boolean parentTokenEqualsCurrentNodeToken = node.is(linkingParent.getNodeToken().getName());
        if (!parentTokenEqualsCurrentNodeToken)
        {
          intermediateFeatureNode = createTargetFeature(tokenTree, sourceFeature, isSubFeature);
          createFeatureModelSegment(intermediateFeatureNode,rightTokenTree,isSubFeature);
          createFeatureModelSegment(intermediateFeatureNode,leftTokenTree,isSubFeature);
        }
        else 
        {
          createFeatureModelSegment(sourceFeature,rightTokenTree,isSubFeature);
          createFeatureModelSegment(sourceFeature,leftTokenTree,isSubFeature);
        }

    }
  }
  /*
  This method filters unwanted tokens & changes the form of require-statement argument from 
  nested tokens, as the parser does, to list of tokens.  
  */
  public ArrayList<Token> getRequireStatementTokensAsList(Token requireStatementToken, List<String> acceptedTokensList)
  {
    ArrayList<Token> TokenList =  new ArrayList<Token>();
    Token terminal;
    for(Token innerToken : requireStatementToken.getSubTokens())
    {
      if (! innerToken.getName().equals("") && acceptedTokensList.contains(innerToken.getName()))
      {
        TokenList.add(innerToken);
      }
      else if (innerToken.getSubTokens() != null)
      	TokenList.addAll(getRequireStatementTokensAsList(innerToken,acceptedTokensList)); // this to obtain [and] out of [requireLinkingOp] 
    }
    return TokenList;
  }
  
  /*
  This methods returns the mixset in which require-statement was found.
  It returns null if the require-statement is in a file (not inside a mixset). 
	*/
  private Mixset getMixsetFromToken(Token token) {
  	Token parentToken = token.getParentToken();
  	if (parentToken.is("mixsetDefinition"))
  	  return model.getMixset(parentToken.getValue());
  	
  	return null;
	}

/*
This method parses req-statement argument & generates a binary tree representation form the req-statment argument.
//It returns one node (root node) if there is no argument to parse.
*/
private ArrayList<TokenTree> generateFeatureTreeTokenFromRequireStList(ArrayList<Token> tokenList)
{
  TokenTree rootTokenTree = new TokenTree(new Token("ROOT",""));
  TokenTree currentTree = rootTokenTree;		
  List<String> linkingOpList = Arrays.asList("and","or","xor");
	ArrayList<TokenTree> tokenTreeList = new ArrayList<TokenTree>();
  
  for (int i=0;i<tokenList.size();i++)
  {
    Token token = tokenList.get(i);
    TokenTree rightTokenTree = new TokenTree(token);
    //Start(1): put each [opt/not][terminal] in a separate TokenTree if it was preceded with [terminal]
    if(token.is("opt") || token.is("not"))
    {
      if(currentTree.getNodeToken().is("requireTerminal") && tokenList.get(i+1).is("requireTerminal")) // A opt B
      {
        rightTokenTree.setRightTokenTree(new TokenTree(tokenList.get(i+1)));
        // setParent to rightTokenTree
        tokenTreeList.add(rightTokenTree);
        i++; //skip opt terminal 
        continue;
      }
    }
    //End(1)
    if(linkingOpList.contains(token.getName()))
    rightTokenTree.setIsLinkingOperator(true);
    currentTree.setRightTokenTree(rightTokenTree);
    rightTokenTree.setParentTokenTree(currentTree);
    currentTree = rightTokenTree;
  }
  currentTree = rootTokenTree.getRightTokenTree(); //currentTree points to the first node of the tree
  
  TokenTree previousLinkingSubTokenTree = null; 
		
  while(currentTree.getRightTokenTree() != null)
 	{
		TokenTree rightLinkingTokenTree = currentTree.getRightTokenTree(); //linking operator on the right of current node 	
    if(rightLinkingTokenTree == null)
    break;
    if(currentTree.getNodeToken() == null || currentTree.getNodeToken().getName() == null ) 
     continue;
    if(currentTree.getNodeToken().is("requireTerminal") && rightLinkingTokenTree.getIsLinkingOperator())
    {
		// A and B --> (and A B)
    	if (previousLinkingSubTokenTree == null)
      {
      	currentTree.setParentTokenTree(rightLinkingTokenTree);
        rightLinkingTokenTree.setLeftTokenTree(currentTree);
        rightLinkingTokenTree.setParentTokenTree(rootTokenTree);
        rootTokenTree.setRightTokenTree(rightLinkingTokenTree);
        previousLinkingSubTokenTree = rightLinkingTokenTree;
      }
      else
	    {
		    /*
				this for the case : A and B or C --> (or (and A B))
		    */
		    if(previousLinkingSubTokenTree.getPriority() >= rightLinkingTokenTree.getPriority())
		    { 
		    	TokenTree linkNodeToReplace = previousLinkingSubTokenTree;
		      while(linkNodeToReplace != null && ! linkNodeToReplace.getNodeToken().getName().equals("ROOT") )
		      {
		      	if (linkNodeToReplace.getPriority() >= rightLinkingTokenTree.getPriority() )
		        {
							previousLinkingSubTokenTree = linkNodeToReplace;
		        }
						linkNodeToReplace = linkNodeToReplace.getParentTokenTree();
		      }
		      rightLinkingTokenTree.setLeftTokenTree(previousLinkingSubTokenTree);
          rightLinkingTokenTree.setParentTokenTree(previousLinkingSubTokenTree.getParentTokenTree());
		      previousLinkingSubTokenTree.getParentTokenTree().setRightTokenTree(rightLinkingTokenTree); 
		      previousLinkingSubTokenTree.setParentTokenTree(rightLinkingTokenTree);
		      previousLinkingSubTokenTree=rightLinkingTokenTree;	
		    }
		    else
			  {
					/*
		    	this for the case : A or B and C --> or (and A B)
		    	*/
		    	rightLinkingTokenTree.setLeftTokenTree(currentTree);
					rightLinkingTokenTree.setParentTokenTree(previousLinkingSubTokenTree);
			  	previousLinkingSubTokenTree.setRightTokenTree(rightLinkingTokenTree);
		      previousLinkingSubTokenTree = rightLinkingTokenTree;
		    }
		  }
    	// last step: set right node of terminal to null 
    	currentTree.setRightTokenTree(null);
  		}
  	currentTree = rightLinkingTokenTree; // move to next node of the tree 
		}
  tokenTreeList.add(rootTokenTree.getRightTokenTree());
	return tokenTreeList;	
	}

  public void analyzeFeatureModel()
  {
    if(model.getFeatureModel() != null)
    model.getFeatureModel().satisfyFeatureModel();
  }
}


class FeatureModel{
/*
 * This method returns a leaf node from FeatureModel based on its name.
 * return null if the leaf node is not found.   
 */
  public FeatureLeaf getFeatureLeafNode(String name)
  {
    for(FeatureNode aNode: node)
    {
      if(aNode.getName().equals(name) && aNode.getIsLeaf()) // isLeaf
      return ((FeatureLeaf) aNode);
    }
    return null;
  }
  /*
  This method does conditional addition for a FeatureLeaf based on the provided name. 
  It returns a new FeatureLeaf if its not found, or existing FeatureLeaf if the name was found.
  */
  public FeatureLeaf getOrCreateFeatureLeafNode(String name)
  {
    FeatureLeaf aNode = getFeatureLeafNode(name);
    if(aNode == null)
    {
      aNode = new FeatureLeaf(this);
      aNode.setName(name);
    }
    return aNode; 
  }
  
  public boolean evaluateFeatureLink(FeatureLink featureLink)
  {
    FeatureNode featureNode = ((FeatureNode) featureLink.getTargetFeature(0));

    if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Include))
    {
      FeatureLeaf fNode = ((FeatureLeaf) featureLink.getTargetFeature(0));
      boolean isMixset = fNode.getMixsetOrFileNode().getIsMixset();
      if(isMixset)
      {
        Mixset mixset = getUmpleModel().getMixset(fNode.getMixsetOrFileNode().getName());
        if(mixset != null)
        {
          if(mixset.getUseUmpleFile() != null)
          return true;  // this means there is a use-statement here
          //else there is no use-statement    
        }
        else 
        {
          return false;//there is no mixset with the specified name. 
        }
      }
    } 
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Exclude))
    {
      FeatureLeaf fNode = ((FeatureLeaf) featureLink.getTargetFeature(0));
      boolean isMixset = fNode.getMixsetOrFileNode().getIsMixset();
      if(isMixset)
      {
        Mixset mixset = getUmpleModel().getMixset(fNode.getMixsetOrFileNode().getName());
        if(mixset != null)
        {
           if(mixset.getUseUmpleFile() == null)
          return true;  // this means there is no use-statement here
          //else there is use-statement   
        }
        else 
        {
          return false;//raise error here ... 
        }
      }
    }
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Optional))
    {
      // opt is allawys has a true value 
      return true;
    } 
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Conjunctive))
    { 
      FeatureNode fNode = ((FeatureNode) featureLink.getTargetFeature(0));
      if(!fNode.getIsLeaf())
      {
        List<FeatureLink> outgoingLinks = fNode.getSourceFeatureLink();
        for(int i=0 ; i<outgoingLinks.size()-1; i++){
          return evaluateFeatureLink(outgoingLinks.get(i)) && evaluateFeatureLink(outgoingLinks.get(i+1));
        }
      }
    }
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Disjunctive))
    {   
      FeatureNode fNode = ((FeatureNode) featureLink.getTargetFeature(0));
      if(!fNode.getIsLeaf())
      {
        List<FeatureLink> outgoingLinks = fNode.getSourceFeatureLink();
        for(int i=0 ; i<outgoingLinks.size()-1; i++){
          return evaluateFeatureLink(outgoingLinks.get(i)) || evaluateFeatureLink(outgoingLinks.get(i+1));
        }
      }
    }
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.XOR))
    { 
      FeatureNode fNode = ((FeatureNode) featureLink.getTargetFeature(0));
      if(!fNode.getIsLeaf())
          {
            List<FeatureLink> outgoingLinks = fNode.getSourceFeatureLink();
            for(int i=0 ; i<outgoingLinks.size()-1; i++){
              return evaluateFeatureLink(outgoingLinks.get(i)) ^ evaluateFeatureLink(outgoingLinks.get(i+1));
            }
          }
    }
    else if(featureLink.getFeatureConnectingOpType().equals(FeatureLink.FeatureConnectingOpType.Multiplicity))
    { //To DO
      return true;
    }
    else if(featureNode.getIsLeaf())
    {
      FeatureLeaf featureleaf = (FeatureLeaf) featureNode;
      boolean isMixset = featureleaf.getMixsetOrFileNode().getIsMixset();
      if(isMixset)
      {
        Mixset mixset = getUmpleModel().getMixset(featureleaf.getMixsetOrFileNode().getName());
        if(mixset != null)
        {
          if(mixset.getUseUmpleFile() != null)
          return true;  // this means there is a use-statement here
          //else there is no use-statement    
        }
        else 
        {
          return false;//there is no mixset with the specified name. 
        }
      }
    }
    return false;
  }

  depend java.util.stream.*;
  public void satisfyFeatureModel()
  {
    UmpleModel model = getUmpleModel();
    //if(featureModel == null)
    //return ; // there is no any feature model the current umple file.
    //else
    //get leaf features that has outgoing links, they are the root of the feature model in this case
    // check each link based on the type of the link
    List <FeatureNode> rootFeatures = getNode().stream().filter(n -> (n.hasSourceFeatureLink() && n.getIsLeaf())).collect(Collectors.toList());
    for(FeatureNode featureNode: rootFeatures)
    {
      List <FeatureLink> featureNodeOutLinks = featureNode.getSourceFeatureLink();
      for(FeatureLink flink : featureNodeOutLinks)
      {
        evaluateFeatureLink(flink);
      }
    }
  }

}

/*
This class used to represent the binary tree of require-statement argument 
Ex: require [A and B or C] will be formed as: 
          ... or...  
   ... and...      C
  A           B    
*/
class TokenTree
{
  depend cruise.umple.parser.Token;
  Token nodeToken;
  lazy TokenTree parentTokenTree;
  lazy TokenTree leftTokenTree;
  lazy TokenTree rightTokenTree;
  
  boolean isNegated =false;
  boolean isOpt = false;
  boolean isLinkingOperator = false;
/*
This method selects the the connection operator type based on the type of the (linking) token.
If the type is not specified for the linking node, The default is Required.
It returns null if the node is termainl node.
*/
public FeatureLink.FeatureConnectingOpType getFeatureConnectionOpType()
{
  if(nodeToken != null )
  {
    String operator = nodeToken.getName();
    switch (operator) {
      case "and":
        return FeatureLink.FeatureConnectingOpType.Conjunctive;
      case "or":
        return FeatureLink.FeatureConnectingOpType.Disjunctive;
      case "xor":
        return FeatureLink.FeatureConnectingOpType.XOR;
      case "multiplicityTerminal":
        return FeatureLink.FeatureConnectingOpType.Multiplicity;
      case "opt":
        return FeatureLink.FeatureConnectingOpType.Optional;
      case "not":
        return FeatureLink.FeatureConnectingOpType.Exclude;
      default:
        return FeatureLink.FeatureConnectingOpType.Required;
     }
  }

  return null;
}
/*
This methods returens the priority of a node to move down in the binary tree.
high priority node moves down & low prioriy moves up 
not > and > xor > or > ROOT (Top of the tree)
*/
  public int getPriority()
  {
    String tokenName = nodeToken.getName();
    switch (tokenName)
    {
      case "and":
      return 3;
      case "xor":
      return 2;
      case "or":
      return 1;
      case "ROOT":
      return 0;
    }
    return -1; // lower priority, leaf nodes should not move 
  }

}
