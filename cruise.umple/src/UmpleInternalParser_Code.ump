/*

Copyright 2010 Andrew Forward, Omar Badreddin, Timothy C. Lethbridge

This file is made available subject to the open source license found at:
http://cruise.site.uottawa.ca/UmpleMITLicense.html

This file contains the implementation details for our internal Umple parser.

This class parses an Umple file into an abstract syntax tree of tokens, which are then
analyzed into an Umple meta model.  This meta model can then be passed to our code generator
to generate target implementations such as Java, PHP and Ruby.  It is configured to mostly
delegate to helper methods for the following components

 + Core (most things outside of the elements below)
 + Umple Classes
 + State Machines
 + Traces
 + Layouts

The grammar is parsed from the *.grammar files in the /src directory.  Please refer to the
addRulesInFile() methods to see which files comprise the current grammar.

This file also contains helper methods for delegating the analysis of token, so that
we properly populate the Umple instance of the Umple meta-model.

Please refer to UmpleInternalParser.ump for more details.

*/

namespace cruise.umple.compiler;

class UmpleInternalParser
{
  
  internal String[] unparsedUmpleFiles;
  internal String[] parsedUmpleFiles;
  after constructor { init(); }
  
  
  public UmpleInternalParser()
  {
    this("UmpleInternalParser",new UmpleModel(null));
  }

  public UmpleInternalParser(UmpleModel aModel)
  {
    this("UmpleInternalParser",aModel);
  }

  private void init()
  {
    addCouple(new Couple("\"","\""));
    addCouple(new Couple("{","}"));
    addRulesInFile("/umple_core.grammar");
    addRulesInFile("/umple_classes.grammar");
    addRulesInFile("/umple_patterns.grammar");
    addRulesInFile("/umple_state_machines.grammar");
    addRulesInFile("/umple_traces.grammar");
    addRulesInFile("/umple_layout.grammar");
  }

  public ParseResult parse(String ruleName, String input)
  {
    return super.parse(ruleName,input);
  }

  public ParseResult analyze(boolean shouldGenerate)
  {
    parseAllFiles();
    analyzeAllTokens(getRootToken());
    postTokenAnalysis();
    if (shouldGenerate && getParseResult().getWasSuccess())
    {
      model.generate();
    }
    return getParseResult();
  }

  //------------------------
  // PRIVATE METHODS
  //------------------------

  // When an error occurs, set the failed position and mark the compile as NOT successful
  private void setFailedPosition(Position position)
  {
    getParseResult().setWasSuccess(false);
    getParseResult().setPosition(position);
  }

  // Analyze all child tokens of the "root" token.  This delegates to a individual
  // analyzeToken and quits early if a problem arises
  private void analyzeAllTokens(Token rootToken)
  {
    for(Token t : rootToken.getSubTokens())
    {
      analyzeToken(t);
      if (!getParseResult().getWasSuccess())
      {
        return;
      }
    }
  }

  // Delegate function to analyze a token within the context of a class
  // Each token is analyzed twice, analysisStep is "1" is for the first round of analsys
  // and "2" for the second.  The "2" is used for chicken-and-egg initialization problems, otherwise
  // put everything under the "1"
  private void analyzeAllTokens(Token rootToken, UmpleClass aClass, int analysisStep)
  {
    for(Token token : rootToken.getSubTokens())
    {
      analyzeToken(token,aClass,analysisStep);
      if (!getParseResult().getWasSuccess())
      {
        break;
      }
    }
  }

  // Delegate function to analyze a token and send it to the write
  private void analyzeToken(Token t)
  {
    analyzeCoreToken(t);
    analyzeClassToken(t);
    analyzeStateMachineToken(t);
    analyzeTraceToken(t);
    analyzeLayoutToken(t);
  }

  // Analyze an individual token, delegates to the various components in Umple
  private void analyzeToken(Token t, UmpleClass aClass, int analysisStep)
  {
    analyzeCoreToken(t,aClass,analysisStep);
    analyzeClassToken(t,aClass,analysisStep);
    analyzeStateMachineToken(t,aClass,analysisStep);
    analyzeTraceToken(t,aClass,analysisStep);
    analyzeLayoutToken(t,aClass,analysisStep);
  }
  
  // Once you have analyze all tokens, you allowed a second 'pass' to apply any additional checks
  // Each step in the process might "fail", so we check the status before calling each delegate
  // token post token analysis method
  private void postTokenAnalysis()
  {
    
    if (getParseResult().getWasSuccess())
    {
      postTokenCoreAnalysis();
    }
    
    if (getParseResult().getWasSuccess())
    {
      postTokenClassAnalysis();  
    }

    if (getParseResult().getWasSuccess())
    {
      postTokenStateMachineAnalysis();
    }
    
    if (getParseResult().getWasSuccess())
    {
      postTokenTraceAnalysis();  
    }

    if (getParseResult().getWasSuccess())
    {
      postTokenLayoutAnalysis();
    }

  }


  // Locate all 'use *.ump' references and add those files if not already parsed 
  private void addNecessaryFiles()
  {
    for(Token t : getRootToken().getSubTokens())
    {
      if (t.is("use"))
      {
        String filename = model.getUmpleFile().getPath() + File.separator + t.getValue();

        if (!parsedUmpleFiles.contains(filename) && !unparsedUmpleFiles.contains(filename))
        {
          unparsedUmpleFiles.add(filename);
        }
      }
    }
  }
  
  // Loop through all unparsed files, parse them, and add any missing references
  private void parseAllFiles()
  {
    addNecessaryFiles();
    while (!unparsedUmpleFiles.isEmpty())
    {
      String nextFile = unparsedUmpleFiles.get(0);
      unparsedUmpleFiles.remove(0);
      parsedUmpleFiles.add(nextFile);
      String input = SampleFileWriter.readContent(new File(nextFile));
      parse("program", input);
      addNecessaryFiles();
    }    
  }  

}

use UmpleInternalParser_CodeCore.ump;
use UmpleInternalParser_CodeClass.ump;
use UmpleInternalParser_CodeStateMachine.ump;
use UmpleInternalParser_CodeTrace.ump;
use UmpleInternalParser_CodeLayout.ump;
