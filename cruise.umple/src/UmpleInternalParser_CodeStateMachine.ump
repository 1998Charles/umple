/*

Copyright 2010 Andrew Forward, Omar Badreddin, Timothy C. Lethbridge

This file is made available subject to the open source license found at:
http://cruise.site.uottawa.ca/UmpleMITLicense.html

This file analyzes token related State Machines and populates the State Machine
related meta model entities in Umple.

Please refer to UmpleInternalParser.ump for more details.

*/

namespace cruise.umple.compiler;

class UmpleInternalParser
{
  internal StateMachine placeholderStateMachine = null;
  internal Map<String,Token> stateMachineNameToToken = new HashMap<String, Token>();
  internal Map<UmpleClass,Pair> umpleClassToStateMachineDefinition = new HashMap<UmpleClass, Pair>();
  
  // Analyze state machine related tokens
  private void analyzeStateMachineToken(Token token)
  {
    if (token.is("stateMachineDefinition"))
    {
      analyzeStateMachineDefinition(token);
    }
  }  
  
  // Analyze state machine related tokens within the context of an Umple class
  private void analyzeStateMachineToken(Token token, UmpleClass aClass, int analysisStep)
  {
    if (analysisStep != 1)
    {
      return;
    }
    
    if (token.is("stateMachine"))
    {
      Token subToken = token.getSubToken(0);
      if (subToken.is("enum") || subToken.is("inlineStateMachine"))
      {
        analyzeStateMachine(subToken,aClass);
      }
      else if (subToken.is("referencedStateMachine"))
      {
        analyzedReferencedStateMachine(subToken,aClass);
      }
    }
  }

  
  private void postTokenStateMachineAnalysis()
  {
    addReferencedStateMachines();
  }
  
  private void addReferencedStateMachines()
  {
    for (UmpleClass clazz : umpleClassToStateMachineDefinition.keySet())
    {
      Pair nameToDefinition = umpleClassToStateMachineDefinition.get(clazz);
      Token stateMachineToken = stateMachineNameToToken.get(nameToDefinition.getValue());
      if (stateMachineToken == null)
      {
        continue;
      }

      StateMachine sm = new StateMachine(nameToDefinition.getName());
      sm.setUmpleClass(clazz);

      // analyze meta states

      populateStateMachine(stateMachineToken,sm);
    }
  }
  
  private void analyzeStateMachineDefinition(Token stateMachineDefinitionToken)
  {
    StateMachine smd = analyzeStateMachine(stateMachineDefinitionToken,null);
    model.addStateMachineDefinition(smd);
  }

  private void analyzedReferencedStateMachine(Token stateMachineToken, UmpleClass aClass)
  {
    String name = stateMachineToken.getValue("name");
    String value = stateMachineToken.getValue("definitionName");
    umpleClassToStateMachineDefinition.put(aClass,new Pair(name,value));


    // analyze meta states
  }

  private StateMachine analyzeStateMachine(Token stateMachineToken, UmpleClass aClass)
  {
    placeholderStateMachine = new StateMachine("PLACE_HOLDER");
    String name = stateMachineToken.getValue("name");
    stateMachineNameToToken.put(name,stateMachineToken);
    StateMachine sm = new StateMachine(name);
    sm.setUmpleClass(aClass);
    populateStateMachine(stateMachineToken, sm);

    while (placeholderStateMachine.numberOfStates() > 0)
    {
      placeholderStateMachine.getState(0).setStateMachine(sm);
    }
    return sm;
  }

  private State createStateFromTransition(Token transitionToken, StateMachine sm)
  {
    String name = transitionToken.getValue("stateName");
    State nextState = sm.findState(name);
    if (nextState == null)
    {
      nextState = placeholderStateMachine.findState(name);
    }

    if (nextState == null)
    {
      nextState = new State(transitionToken.getValue("stateName"),placeholderStateMachine);
    }
    return nextState;
  }

  private State createStateFromDefinition(Token stateToken, StateMachine sm)
  {
    State s = sm.findState(stateToken.getValue("stateName"),false);
    if (s == null)
    {
      s = placeholderStateMachine.findState(stateToken.getValue("stateName"));
      if (s != null)
      {
        s.setStateMachine(sm);
      }
    }
    if (s == null)
    {
      s = new State(stateToken.getValue("stateName"),sm);
    }
    return s;
  }

  private void populateStateMachine(Token stateMachineToken, StateMachine sm)
  {
    boolean isFirst = true;
    for(Token stateToken : stateMachineToken.getSubTokens())
    {
      if (!stateToken.is("state") && !stateToken.is("stateName"))
      {
        continue;
      }

      State s = createStateFromDefinition(stateToken,sm);
      if (isFirst)
      {
        s.setIsStartState(true);
      }
      isFirst = false;
      analyzeState(stateToken, s);
    }
  }

  private void analyzeState(Token stateToken, State fromState)
  {
      boolean addNewSm = true;
      boolean isConcurrentState = false;
    for(Token subToken : stateToken.getSubTokens())
    {
      if (subToken.is("transition"))
      {
        analyzeTransition(subToken, fromState); 
        continue;
      }
      else if (subToken.is("activity"))
      {
        analyzeActivity(subToken, fromState);
      }
      else if (subToken.is("entryOrExitAction"))
      {
        Action action = new Action(subToken.getValue("actionCode"));
        action.setActionType(subToken.getValue("type"));
        fromState.addAction(action);
      }
      else if (subToken.is("||"))
      {
        if (fromState.numberOfNestedStateMachines() == 0) { continue; }
        int previousSmIndex = fromState.numberOfNestedStateMachines() - 1;
              StateMachine nestedSm = fromState.getNestedStateMachine(previousSmIndex);
              if (nestedSm.numberOfStates() == 0) { continue; }
              nestedSm.setName(nestedSm.getState(0).getName());
              addNewSm = true;
              isConcurrentState = true;
      }
      else if (subToken.is("state"))
      {
        StateMachine nestedStateMachine = null;
        if (addNewSm)
        {
          nestedStateMachine = new StateMachine(fromState.getName());
          fromState.addNestedStateMachine(nestedStateMachine);
        }
        else
        {
          int lastIndex = fromState.numberOfNestedStateMachines() - 1;
          nestedStateMachine = fromState.getNestedStateMachine(lastIndex);
        }
        State s = createStateFromDefinition(subToken,nestedStateMachine);
        //alignStateDefinitionWithStateMachine(s,nestedStateMachine);
        if (addNewSm)
        {
                  if (isConcurrentState)
                  {
                    nestedStateMachine.setName(s.getName());
                  }
          s.setIsStartState(true);
        }
        addNewSm = false;
        analyzeState(subToken, s);
      }
    }
  }

  private void analyzeActivity(Token activityToken, State fromState)
  {
    new Activity(activityToken.getValue("activityCode"),fromState);
  }


  private void analyzeTransition(Token transitionToken, State fromState)
  {
    State nextState = createStateFromTransition(transitionToken,fromState.getStateMachine());
    Transition t = new Transition(fromState, nextState);

    String eventName = transitionToken.getValue("event");
    String eventTimerAmount = transitionToken.getValue("timer");

    if (eventName == null && eventTimerAmount != null)
    {
      eventName = fromState.newTimedEventName(nextState);
    }

    Token guardToken = transitionToken.getSubToken("guard");
    if (guardToken != null)
    {
      t.setGuard(new Guard(guardToken.getValue("guardCode")));
    }

    Token actionToken = transitionToken.getSubToken("action");
    if (actionToken != null)
    {
      t.setAction(new Action(actionToken.getValue("actionCode")));
    }

    if (eventName != null)
    {
      StateMachine sm = fromState.getStateMachine();
      UmpleClass uClass = sm.getUmpleClass();
      Event event = uClass == null ? sm.findOrCreateEvent(eventName) : uClass.findOrCreateEvent(eventName);
      if (eventTimerAmount != null)
      {
        event.setIsTimer(true);
        event.setTimerInSeconds(eventTimerAmount);
      }
      t.setEvent(event);
    }

  }  

} 