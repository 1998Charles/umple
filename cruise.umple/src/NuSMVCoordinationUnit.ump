namespace cruise.umple.nusmv;

use NuSMVMetamodel.ump;

class NuSMVCoordinator
{
  depend cruise.umple.compiler.*;
  depend java.util.*;

	space <<!

!>>
  output <<!-- This file is generated from <<=model.getUmpleFile().getFileName()>> --!>>
  emit commentModel(UmpleModel model)(output,space); 
  
  	/**
  * This changes the first caharacter of a given string.
  * @param str the given string.
  * @param index value 0 - Lowercase, 1 - Uppercase, Otherwise no change
  * @return the resulting string value.
  */
  public String changeNameCase(String str , int index) {
    	char[] stringArray = str.trim().toCharArray();
    	if(index == 1)
    		stringArray[0] = Character.toUpperCase(stringArray[0]);
    	if(index == 0)
    		stringArray[0] = Character.toLowerCase(stringArray[0]);
    	str = new String(stringArray);
    	return str;
  	}
  	
  	public boolean isNested(StateMachine sm) {
  		boolean yes = false;
  		for(State st : sm.getStates()) 
  			if(st.numberOfNestedStateMachines() > 0) {
  				yes = true;
  				break;
  			}
  		return yes;
  	}
  	
  	public StringBuilder generateSimpleModule( StateMachine sm ) {
  		if(isNested(sm)) 
  			return null;
  		
  		StringBuilder temp = new StringBuilder();
  		//Generates enumeration list for the events recognized by the system
  		IVarDeclaration ivar = new IVarDeclaration(getEventList( sm ));
  		
  		//Creates the state variables for the given state machine
  		VarDeclaration vdec = new VarDeclaration(getStateList(sm));
  		ModuleBody body = new ModuleBody(ivar);
  		body.addModuleElement(vdec);
  		
  		//Adding define declaration to module body
  		body.addModuleElement(getDefineDeclaration(sm));
  		body.addModuleElement(getAssignConstraint( sm) );
  		
  		NuSMVModule module = new NuSMVModule(changeNameCase(sm.getFullName(), 1), body);
  		temp.append(module.toString());
  		
  		//Generating the main module for the statemachine
  		body = new ModuleBody(genMainVariableFor( sm ));
  		module = new NuSMVModule("main", body);	
  		generateSpecForStateReachability( sm, body ); 
  		temp.append("\n"+module.toString());
  		return temp;
  	}
  	
  	private int getTransitionIdentity( StateMachine sm, Transition tr) {
  		int pos = 1;
  		for(Transition trans : sm.getAllTransitions() ) {
  			if(trans.equals(tr))
  				return pos;
  			pos++;
  		}
  		return -1;
  	}
  	
  	private void generateSpecForStateReachability( StateMachine sm, ModuleBody body ) {
  		
  		for( State st : sm.getStates() ) {
  			BasicExpression bexp1 = new BasicExpression(changeNameCase(sm.getFullName(), 0)+".state");
    		BasicExpression bexp2 = new BasicExpression(st.getName());
    		CTLExpression cexp = new CTLExpression("ctl");
    		cexp.addChild(bexp1);
    		cexp.addChild(bexp2);
    		cexp.setOperator(cexp.getOperator().EQ);
    		cexp.setBracketed(true);
    		cexp.setQualified(true);
    		cexp.setCtlOperator(cexp.getCtlOperator().EF);
    		CTLSpecification cspec = new CTLSpecification(cexp);
    		body.addModuleElement(cspec);
    	}
  	}
  	
  	private AssignConstraint getAssignConstraint( StateMachine sm) {
  		BasicExpression bexp = new BasicExpression(sm.getStartState().getName());
  		InitAssign ia = new InitAssign("state", bexp);
  		AssignConstraint ac = new AssignConstraint(ia);
  		ac.addAssign(getNextAssign( sm ));
  		return ac;
  	}
  	
  	private NextAssign getNextAssign( StateMachine sm ) {
  		BasicExpression bexp1 = new BasicExpression("state");
    	BasicExpression bexp2 = new BasicExpression("TRUE");
    	CaseStatement temp = new CaseStatement(bexp2, bexp1);
    	CaseExpression expr = new CaseExpression("",temp);
    	for(State st : sm.getStates() ) {
    		CaseStatement cstatement = getCaseStatement(sm, st);
    		if( cstatement != null)
    			expr.addCaseStatement(cstatement);
    	}
    	CaseStatement otherwise = new CaseStatement(bexp2, bexp1);
    	expr.addCaseStatement( otherwise);
    	expr.removeCaseStatement(temp);
    	NextAssign na = new NextAssign("state", expr);
    	return na;
  	}
  	
  	private CaseStatement getCaseStatement( StateMachine sm, State st ) {
  		int counter = 0;
  		BasicExpression root = new BasicExpression("root");
  		for(Transition tr : st.getNextTransition()) {
  			BasicExpression bexp = new BasicExpression("t"+getTransitionIdentity( sm, tr) );	
  			root = 	getExpressionTreeFor( root, bexp );	
  			counter++;
  		}
  		if(counter > 0) {
  			BasicExpression state = new BasicExpression( st.getName() ); 
  			return new CaseStatement(root, state);
  		}
  		return null;
  	}
  	
  	private BasicExpression getExpressionTreeFor( BasicExpression root, BasicExpression bexp ) {
  		if( root.getChildren().size() < 2) {
  			root.addChild(bexp); 
  			root.setOperator(root.getOperator().OR);
  		}
  		else {
  			BasicExpression temp = new BasicExpression(root.getChildren().get(0).getIdentifier());
  			temp.addChild(root.getChildren().get(0));
  			temp.addChild(bexp);
  			temp.setOperator(temp.getOperator().OR);
  			root.addChild(temp);
  		}
  		return root;
  	}
  	
  	private VarDeclaration genMainVariableFor( StateMachine sm ) {
  		VariableSpecifier vs = new VariableSpecifier(changeNameCase(sm.getFullName(), 0));	
  		vs.addTypeSpecifier( changeNameCase(sm.getFullName(), 1));
  		VarDeclaration vdec =  new VarDeclaration(vs); 
  		if(!isNested(sm)) 
  			return vdec;
  		for( StateMachine smm : sm.getNestedStateMachines() ) {
  			vs = new VariableSpecifier(changeNameCase(smm.getFullName(), 0));
  			vs.addTypeSpecifier( changeNameCase(smm.getFullName(), 1));
  			vdec.addVariableSpecifier(vs);
  		}
  		return vdec;
  	}
  	
  	//Generates event enumeration for a given state machine
  	private  VariableSpecifier getEventList( StateMachine sm ) {
  		VariableSpecifier vs = new VariableSpecifier("event");
  		for( Event event : sm.getAllEvents() ) 
  			vs.addTypeSpecifier(event.getName());
  		return vs;
  	}
  	
  	//Generates state enumeration for a given state machine
  	private VariableSpecifier getStateList(StateMachine sm) {
  		VariableSpecifier vs = new VariableSpecifier("state");
  		for(State st : sm.getStates())
  			vs.addTypeSpecifier(st.getName());
  		if(sm.getParentState() != null)
  			vs.addTypeSpecifier("null");
  		return vs;
  	}
  		
  	//Generates the define part for all the transitions of the system
  	private DefineDeclaration getDefineDeclaration( StateMachine sm ) {
  		int i = 1;
  		BasicExpression temp = new BasicExpression("null");
  		DefineBody dnull = new DefineBody("null", temp);
  		DefineDeclaration ddec = new DefineDeclaration(dnull);
  		for( Transition tr : sm.getAllTransitions() ) {
  			BasicExpression bexp = composeExpressionFor( tr );
  			DefineBody dBody = new DefineBody("t"+getTransitionIdentity( sm, tr) , bexp);
  			ddec.addDefineBody(dBody);
  			i++;
  		}
  		ddec.removeDefineBody(dnull);
  		return ddec;
  	}
  	
  	private BasicExpression composeExpressionFor( Transition tr ) {
  		BasicExpression bexp1 = new BasicExpression("event");
  		BasicExpression bexp2 = new BasicExpression(tr.getEvent().getName());
  		BasicExpression bexp3 = new BasicExpression("eventExpr"); 
  		bexp3.addChild(bexp1);
  		bexp3.addChild(bexp2);
  		bexp3.setOperator(bexp3.getOperator().EQ);
  			
  		BasicExpression bexp4 = new BasicExpression("state");
  		BasicExpression bexp5 = new BasicExpression(tr.getFromState().getName()); 
  		BasicExpression bexp6 = new BasicExpression("stateExpr");
  		bexp6.addChild(bexp4);
  		bexp6.addChild(bexp5);
  		bexp6.setOperator(bexp6.getOperator().EQ); 
  			
  		BasicExpression bexp = new BasicExpression("state");
  		bexp.addChild(bexp3);
  		bexp.addChild(bexp6);
  		
  		return bexp;
  	}
  }