/*

Copyright 2010 Andrew Forward, Omar Badreddin, Timothy C. Lethbridge

This file is made available subject to the open source license found at:
http://cruise.site.uottawa.ca/UmpleMITLicense.html

This class provides helper methods of trace related code generation.

Please refer to GeneratorHelper_Code.ump for more details.

*/

namespace cruise.umple.compiler;

class GeneratorHelper
{
private static void postpareTrace(UmpleModel aModel)
  {}

  // Currently no internal trace entities to remove at the class level
  private static void postpareTrace(UmpleClass aClass)
  {}
  

  // Look through all traces and inject the necessary code in the after, it requires the following lookups
  //  + consoleTemplate
  //  + stringTemplate
  //  + dependPackage 
  //  + executeMethod
  public static void prepareAllStringTracers(CodeTranslator t, UmpleModel model, UmpleClass aClass, Map<String,String> templateLookups)
  {
    String consoleTemplate = templateLookups.get("consoleTemplate");
    String stringTemplate = templateLookups.get("stringTemplate");
    String dependPackage = templateLookups.get("dependPackage");
    String extraCode = templateLookups.get("extraCode");

    // Go over each trace directive
    for (TraceDirective traceDirective : aClass.getTraceDirectives())
    {
      Map<String,String> lookups = new HashMap<String,String>();
      
      //-- if String tracer is used
      if ("String".equals(model.getTraceType()))
      {
        String packageName = model.getDefaultPackage() == null ? "cruise.util" : model.getDefaultPackage();
        lookups.put("packageName",packageName);
        lookups.put("extraCode",extraCode);
        GeneratorHelper.prepareStringTracer(model, lookups);

        if (dependPackage != null && !packageName.equals(aClass.getPackageName()))
        {
          Depend d = new Depend(packageName + ".*");
          d.setIsInternal(true);
          aClass.addDepend(d);
        }
        if (traceDirective.hasAttributes())
        {
        	for( int i = 0 ; i < traceDirective.numberOfAttributes() ; ++i )
        	{
                lookups.put("attributeCode",StringFormatter.format(stringTemplate,t.translate("attribute",traceDirective.getAttribute(i)),t.translate("parameter",traceDirective.getAttribute(i))));
        	}
        }
      }
      if (traceDirective.hasAttributes())
      {
    	  for( int i = 0 ; i < traceDirective.numberOfAttributes() ; ++i )
    	  {
    		  lookups.put("setMethod",t.translate("setMethod",traceDirective.getAttribute(0)));
    	  }
      }
      prepareTraceDirective(traceDirective, lookups, null);
    }   
  }  

  // Add a StringTracer class to support "String" tracing - typically used for testing, this methods 
  // expects the following action semantic lookups
  //  + packageName: What package should this class belong to?
  //  + extraCode: What is the code required to execute the trace 
  public static void prepareStringTracer(UmpleModel model, Map<String,String> lookups)
  {
    UmpleClass aClass = model.addUmpleClass("StringTracer");
    
    if (aClass.numberOfAttributes() == 0)
    {
      aClass.setIsInternal(true);
      aClass.setIsSingleton(true); 
      aClass.setPackageName(lookups.get("packageName"));
      Attribute traces = new Attribute("traces","String",null,null,false);
      traces.setIsList(true);
      aClass.addAttribute(traces);
      aClass.appendExtraCode(lookups.get("extraCode"));
    }
    aClass.createGeneratedClass(model);
  }

  // Inject the necessary "before" and "after" hooks to call the trace, this method expects the following action semantic lookups
  //  + setMethod: What is the name of the setMethod we are attaching the trace to
  //  + attributeCode: What is the trace code that should be executed
  public static void prepareTraceDirective(TraceDirective traceDirective, Map<String,String> lookups, String conditionType)
  {
    UmpleClass aClass = traceDirective.getUmpleClass();
    String setMethod = lookups.get("setMethod");
    String code = lookups.get("attributeCode");
    String injectionType = "after";
    
    if( "where".equals(conditionType) )
    	injectionType = "before";
    else if( "until".equals(conditionType) || "after".equals(conditionType) )
    	injectionType = "after";

    CodeInjection set = new CodeInjection(injectionType, setMethod, code);
    set.setIsInternal(true);
    aClass.addCodeInjection(set);  
  }
}

