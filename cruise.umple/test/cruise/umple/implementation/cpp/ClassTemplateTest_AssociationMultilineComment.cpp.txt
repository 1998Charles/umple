/* EXPERIMENTAL CODE - NON COMPILEABLE VERSION OF C++ */
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE @UMPLE_VERSION@ modeling language!*/


#include <vector>;
#include "Foo.h";

  
  //------------------------
  // CONSTRUCTOR
  //------------------------
  
 Foo::Foo()
  {
    bars = new vector<Bar*>();
  }

  //------------------------
  // INTERFACE
  //------------------------

  Bar Foo::getBar(int index) 
  {
    Bar aBar = bars.get(index);
    return aBar;
  }

  vector<Bar*> Foo::getBars() 
  {
    vector<Bar*> newBars = bars;
    return newBars;
  }

  int Foo::numberOfBars()
  {
    int number = bars.size();
    return number;
  }

  bool Foo::hasBars()
  {
    bool has = bars.size() > 0;
    return has;
  }
  
  int Foo::indexOfBar(Bar aBar)
  {
    int index = std::find(bars.begin(), bars.end(), aBar) - bars.begin();
    return index;
  }
  
  static int minimumNumberOfBars()
  {
    return 0;
  }

  Bar Foo::addBar()
  {
    return new Bar(this);
  }

  bool Foo::addBar(Bar aBar)
  {
    bool wasAdded = false;
    if (bars.contains(aBar)) { return false; }
    Foo existingFoo = aBar.getFoo();
    bool isNewFoo = existingFoo != null && !this.equals(existingFoo);
    if (isNewFoo)
    {
      aBar.setFoo(this);
    }
    else
    {
      bars.add(aBar);
    }
    wasAdded = true;
    return wasAdded;
  }

  bool Foo::removeBar(Bar aBar)
  {
    bool wasRemoved = false;
    //Unable to remove aBar, as it must always have a foo
    if (!this.equals(aBar.getFoo()))
    {
      bars.remove(aBar);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  
  //------------------------
  // DESTRUCTOR
  //------------------------
  
Foo::~Foo()
  {
    for( int i =0; sizeof(bars); i++)
    {
      delete bars[i];
    }
  }

