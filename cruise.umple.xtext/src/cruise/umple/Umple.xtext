grammar cruise.umple.Umple with org.eclipse.xtext.common.Terminals

generate umple "http://www.umple.cruise/Umple"


UmpleModel:
	elements+=AbstractElement*;

AbstractElement:
	Namespace | Glossary  | Generate  | UseStatement | Entity;
	
	
/* -------------------------------------------------------------------------------------------
 * Part similar to umple_core.grammar
 */ 
Glossary:
	{Glossary}"glossary" "{" (words+=Word)* "}";
	
Word:
	singular=STRING ":" plural=STRING ";" ;	
	
Generate:	
	'generate' (java?='Java' | Php?='Php'| Ruby='Ruby')  ";";
	
UseStatement:
	"use" (file=ID)";";

Namespace:
	"namespace" (value=ID) ";";


Entity:  ClassDefinition | InterfaceDefinition | ExternalDefinition | AssociationDefinition | AssociationClassDefinition | StateMachineDefinition;
/* End of part similar to umple_core.grammar */ 


/* -------------------------------------------------------------------------------------------
 * Part similar to umple_classes.grammar
 */ 
ClassDefinition: "class" (name=ID) "{"  
	classContent+=ClassContent*
	"}";

ExternalDefinition : 'external' name=ID '{' classContent+=ClassContent* '}';

InterfaceDefinition: 'interface' name=ID '{' depend+=Depend* '}';

AssociationDefinition: 'association' name=ID '{' association+=Association* '}' ;

ClassContent:
	Attribute | Position | SoftwarePattern | Depend | SymmetricReflexiveAssociation | InlineAssociation | StateMachine;

AssociationClassContent:
	Attribute | Position | SoftwarePattern | Depend | SymmetricReflexiveAssociation | InlineAssociation | StateMachine;

Depend: 'depend' name = extendedID (".*")? ";";

Association:  multiplicity (type1=ID) (rolename1=ID)?  ("->"|"--"|"<-"|"><") multiplicity (type2=ID) (rolename2=ID)? ";";

SymmetricReflexiveAssociation: multiplicity "self" (rolename=ID) ";";

InlineAssociation: multiplicity (rolename1=ID)? ("->"|"--"|"<-"|"><") (multiplicity) (type=ID) (rolename2=ID)? ";";

SingleAssociationEnd: multiplicity (type=extendedID) (rolename=ID)? ";";

AssociationClassDefinition: 'associationClass' name=ID '{' associationClassContent+=AssociationClassContent* '}';
/* End of part similar to umple_classes.grammar */ 

/* -------------------------------------------------------------------------------------------
 * Part similar to umple_patterns.grammar
 */ 
SoftwarePattern:
	isA | Singleton | KeyDefinition | CodeInjection;

isA: 'isA' (extendsClass+=[UmpleElement]) ("," extendsClass+=[UmpleElement])* ";";

Singleton: singleton?="singleton" ";" ;

KeyDefinition: "key" {Key} "{" (keys+=ID ("," keys+=ID)*)? "}";

CodeInjection:"before" (name=extendedID) code=STRING | "after" (name=extendedID) code=STRING; 

Attribute:
	autounique?="autounique" name=extendedID ";" |
	(unique?="unique")? modifier=Modifier? ((type=UmpleAttributeType (list?="[]")?) |
	(object=[ClassDefinition] (list?="[]")?))?  name=extendedID ( '=' value=UmplePrimitiveType)? ";";
/* End of umple_patterns.grammar */ 


/* -------------------------------------------------------------------------------------------
 * Part similar to umple_state_machines.grammar
 */ 

StateMachineDefinition: "statemachine" name=extendedID '{' states+=State '}';

StateMachine: Enum| InlineStateMachine | ReferencedStateMachine ;

InlineStateMachine: name=extendedID '{' states+=State'}' ;

ReferencedStateMachine: name=extendedID 'as' machine=[StateMachineDefinition];

Enum: name=extendedID "{" states+=extendedID ("," states+=extendedID)* "}";

State: name=extendedID '{' (("*")? states+=StateEntity)*  '}'; 

StateEntity: Transition | EntryOrExitAction | (Activity ("->" extendedID ";")?) | State | (expression ";");	
//This covers just activities and activities that cause a state transition

	
Transition: 
	(Guard events+=EventDefinition "->" a=Action? stateName=extendedID ";") |
	(EventDefinition g=Guard? "->" a=Action? stateName=extendedID ";");
	
EventDefinition: AfterEveryEvent | AfterEvent | Event;

Event: name=extendedID ;

AfterEveryEvent: "afterEvery" "(" name=extendedID ")";

AfterEvent: "wait" "(" name=extendedID ")";

Action: "/" code=block;

EntryOrExitAction: (type="entry" |type="exit") "/" actionCode=block;

Activity: "do" '{' code=block '}' ;

Guard: "[" GuardCode "]";

GuardCode: expression;

/* End of umple_state_machines.grammar */ 

/* -------------------------------------------------------------------------------------------
 * Part similar to umple_layout.grammar
 */ 
Position: AssociationPosition |  ElementPosition;

ElementPosition: 'position' (x=INT) (y=INT) (width=INT) (height=INT) ";"; 

AssociationPosition: "position.association" name=ID (c1=Coordinate) (c2=Coordinate) ";";

Coordinate: (x=INT) "," (y=INT);
/* End of umple_layout.grammar */ 


/* -------------------------------------------------------------------------------------------
 * Complement Rules
 */ 
UmpleAttributeType
	: 	"Date"
	|	"Time"
	|	"Double" | "double"
	|	"Integer"|"integer"|"int"
	|	"Boolean"|"boolean"
	|	"String"|"string"
	;

UmplePrimitiveType:
  INT | STRING ;

enum Modifier: IMMUTABLE="immutable"|SETTABLE="settable"|INTERNAL="internal"|DEFAULTED="defaulted"|CONST="const";  

multiplicity: bound | (bound ".." bound);

bound: INT | "*";

UmpleElement:  ClassDefinition | InterfaceDefinition ;
/* End of Complement Rules */ 

block 
    :   {block} '{' blocks+=blockStatement* '}'
    ;


parExpression:	
	'(' expression ')';

assignmentOperator
	:	'='
	|	'+='
	|	'-='
	;

expressionList
	:	expressions+=expression (',' expressions+=expression)*
	;

 
 expression 
	: 	expression1=conditionalExpression (assignmentOperator expression2=expression)?
	;
	
conditionalExpression
    :   expression1=conditionalOrExpression ( '?' expression2=expression ':' expression3=expression )?
    ;

conditionalOrExpression
    :   expression1=conditionalAndExpression ( '||' expressionRest+=conditionalAndExpression )*
    ;

conditionalAndExpression
    :   expression1=equalityExpression ( '&&' expressionRest+=equalityExpression )*
    ;
    
equalityExpression
    :   expression1=relationalExpression ( ('==' | '!=')  expressionRest+=relationalExpression)*
    ;

relationalExpression
	:	expression1=additiveExpression  (relationalOp expressionRest+=additiveExpression)*
	;

relationalOp
	:	"<="
	|	"<"
	|	">="
	|	">"
	;
	
additiveExpression
    :   expression1=multiplicativeExpression ( ('+' | '-') expressionRest+=multiplicativeExpression )*
    ;

multiplicativeExpression
    :   expression1=unaryExpression ( ( '*' | '/' | '%' ) expressionRest+=unaryExpression )*
    ;
    
unaryExpression
    :   '+' exp1=unaryExpression
    |   '-' exp1=unaryExpression
    |   '++' exp1=unaryExpression
    |   '--' exp1=unaryExpression
    |   exp2=unaryExpressionNotPlusMinus
    ;

unaryExpressionNotPlusMinus
    :   '~' unaryExpression
    |   '!' unaryExpression
    |	primary ('++'|'--')?
    ;

primary
	:	parExpression
	|	literal
	;

literal
	:	 {literal}INT
	|	 {literal}DOUBLE
	|	 {literal}STRING
	|	 {literal}extendedID
	|	javaFunctionCall
	|	 {literal}TRUE
	|	 {literal}FALSE
	;
	
	
/** EXPRESSIONS
 *	END
 **/

//LANGUAGE DEPENDENT
functionCall : javaFunctionCall;	//Expand list with more options

functionDeclaration 
	: java=javaFunctionDeclaration;

functionDefinition : java=javaFunctionDefinition;


/** JAVA NATIVE CODE
 *	START
 *	Based on http://www.antlr.org/grammar/1152141644268/Java.g
 *  The following section is based on the above grammar because, like any ANTLR grammar, Xtext must
 *	have no left-side recursion.
**/

//Methods
javaFunctionDeclaration:
("static")? ("public"|"private"|"protected") (returnType=attributeType|"void"|referenceType=ID) name=ID ( "(" (argList+=attributeType argListID+=extendedID ("," argList+=attributeType argListID+=extendedID)*)? ")" | '()');

javaFunctionDefinition: 
decl=javaFunctionDeclaration code=block
;

javaFunctionCall: name=extendedID (("(" args=expressionList? ")")|("()"));


blockStatement
    :	statement
    |	localVariableDeclarationStatement
    ;

localVariableDeclarationStatement
    :    localVariableDeclaration ';'
    ;

localVariableDeclaration
    :   type=attributeType dec=variableDeclarators
    ;
   
variableDeclarators
    :   vd+=variableDeclarator (',' vd+=variableDeclarator)*
    ;

variableDeclarator
    :   name=extendedID ('=' exp=expression)?
    ;

statement
	:	block
	|	ifstatement
	|	forstatement
	|	whilestatement
	|   returnstatement
	|	endstatement
	|	breakstatement
	|	expressionstatement
	|   trystatement
	;

endstatement: {endstatement}';' ;

breakstatement: {breakstatement} "break" ";" ;

ifstatement: {ifstatement}'if' condition=parExpression state1=statement ('else' state2=statement)? ;

forstatement: {forstatement}'for' '(' control=forControl ')' state=statement ;

whilestatement: {whilestatement}'while' condition=parExpression state=statement;

returnstatement: {returnstatement}'return' retVal=expression? ';';

expressionstatement: expression ';';

trystatement: {trystatement}'try' tryBlock=block 'catch' catchBlock= block;


forControl
	:	{forControl} init=forInit? ';' condition=expression? ';' update=forUpdate?
	;

forInit
	:	(expressions+=expression (',' expressions+=expression)*)
	|	localVariableDeclaration
	;

forUpdate
	:	expressionList;

	

//condictionalExpression covers all expressions except "="
//See Expression section for details

attributeType
	: 	"Date"
	|	"Time"
	|	"Double" | "double"
	|	"Integer"|"integer"|"int"
	|	"Boolean"|"boolean"
	|	"String"|"string"
	;


/** JAVA NATIVE CODE
 *	END
**/

// PHP CODE
phpFunction: 'public' 'function' name=ID codeblock=[phpBlock];

phpBlock: '{' code=STRING'}';

// Ruby Code

rubyFunction: RUBY_FUNCTION;


/* -------------------------------------------------------------------------------------------
 * TERMINALS AND DATA TYPES
 */
terminal TRUE: 'true';
terminal FALSE: 'false';
terminal RUBY_FUNCTION: DEF -> END;
terminal DEF: 'def';
terminal END: 'end';
extendedID: ID ("." ID)*;
DOUBLE: INT "." INT;
fileID: CHARS CHARS*;
CHARS: (extendedID|INT);